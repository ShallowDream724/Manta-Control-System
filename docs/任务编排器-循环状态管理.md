# 任务编排器 - 循环状态管理模块

## 核心职责

循环状态管理模块负责：
1. **独立循环跟踪** - 每个并行循环的状态独立管理
2. **精确时间计算** - 基于间隔时间的精确调度
3. **状态持久化** - 循环状态的内存管理和持久化
4. **动态控制** - 支持暂停、恢复、停止等操作

## 循环状态数据结构

### 核心状态定义
```typescript
interface LoopState {
  // 基础标识
  loopId: string;                    // 循环唯一标识
  taskId: string;                    // 所属任务ID
  stepIndex: number;                 // 所属步骤索引
  
  // 执行状态
  currentIteration: number;          // 当前循环次数 (0-based)
  totalIterations: number;           // 总循环次数
  nextExecutionTime: number;         // 下次执行时间戳(ms)
  lastExecutionTime: number;         // 上次执行时间戳(ms)
  
  // 时间控制
  startTime: number;                 // 循环开始时间戳
  intervalMs: number;                // 循环间隔(毫秒)
  
  // 控制状态
  isActive: boolean;                 // 是否活跃(未完成)
  isPaused: boolean;                 // 是否暂停
  isCompleted: boolean;              // 是否已完成
  
  // 子步骤状态
  currentSubStepIndex: number;       // 当前子步骤索引
  subStepStartTime: number;          // 子步骤开始时间
}
```

### 循环管理器类
```typescript
class LoopStateManager {
  private loopStates = new Map<string, LoopState>();
  private completedLoops = new Set<string>();
  
  // 初始化循环状态
  initializeLoop(loop: ParallelLoop, stepStartTime: number, taskId: string, stepIndex: number): void {
    const loopState: LoopState = {
      loopId: loop.id,
      taskId,
      stepIndex,
      currentIteration: 0,
      totalIterations: loop.iterations,
      nextExecutionTime: stepStartTime, // 立即开始第一次循环
      lastExecutionTime: 0,
      startTime: stepStartTime,
      intervalMs: loop.intervalMs,
      isActive: true,
      isPaused: false,
      isCompleted: false,
      currentSubStepIndex: 0,
      subStepStartTime: stepStartTime
    };
    
    this.loopStates.set(loop.id, loopState);
  }
  
  // 获取循环状态
  getLoopState(loopId: string): LoopState | undefined {
    return this.loopStates.get(loopId);
  }
  
  // 获取所有活跃循环
  getActiveLoops(): LoopState[] {
    return Array.from(this.loopStates.values())
      .filter(state => state.isActive && !state.isPaused);
  }
}
```

## 时间计算算法

### 精确时间调度
```typescript
class LoopTimeCalculator {
  // 计算循环的下次执行时间
  static calculateNextExecutionTime(loopState: LoopState): number {
    // 基于开始时间和循环次数计算，避免累积误差
    return loopState.startTime + (loopState.currentIteration * loopState.intervalMs);
  }
  
  // 检查循环是否到期执行
  static isLoopDue(loopState: LoopState, currentTime: number): boolean {
    return loopState.isActive && 
           !loopState.isPaused && 
           !loopState.isCompleted &&
           currentTime >= loopState.nextExecutionTime &&
           loopState.currentIteration < loopState.totalIterations;
  }
  
  // 计算循环进度
  static calculateProgress(loopState: LoopState): number {
    if (loopState.totalIterations === 0) return 1;
    return Math.min(loopState.currentIteration / loopState.totalIterations, 1);
  }
  
  // 计算剩余时间
  static calculateRemainingTime(loopState: LoopState): number {
    const remainingIterations = loopState.totalIterations - loopState.currentIteration;
    return remainingIterations * loopState.intervalMs;
  }
}
```

### 时间漂移补偿
```typescript
// 处理系统时间漂移和执行延迟
class TimeDriftCompensator {
  private static readonly MAX_DRIFT_MS = 50; // 最大允许漂移50ms
  
  // 检测并补偿时间漂移
  static compensateTimeDrift(loopState: LoopState, currentTime: number): void {
    const expectedTime = loopState.nextExecutionTime;
    const actualTime = currentTime;
    const drift = actualTime - expectedTime;
    
    if (Math.abs(drift) > this.MAX_DRIFT_MS) {
      // 时间漂移过大，重新校准
      console.warn(`Loop ${loopState.loopId} time drift detected: ${drift}ms`);
      this.recalibrateLoop(loopState, currentTime);
    }
  }
  
  // 重新校准循环时间
  private static recalibrateLoop(loopState: LoopState, currentTime: number): void {
    // 基于当前时间重新计算开始时间
    const elapsedIterations = loopState.currentIteration;
    loopState.startTime = currentTime - (elapsedIterations * loopState.intervalMs);
    loopState.nextExecutionTime = this.calculateNextExecutionTime(loopState);
  }
}
```

## 循环状态更新

### 状态推进算法
```typescript
class LoopStateUpdater {
  // 推进循环到下一次迭代
  static advanceLoop(loopState: LoopState, currentTime: number): void {
    // 更新执行时间
    loopState.lastExecutionTime = currentTime;
    loopState.currentIteration++;
    
    // 计算下次执行时间
    loopState.nextExecutionTime = LoopTimeCalculator.calculateNextExecutionTime(loopState);
    
    // 检查是否完成
    if (loopState.currentIteration >= loopState.totalIterations) {
      this.completeLoop(loopState);
    }
    
    // 重置子步骤状态
    loopState.currentSubStepIndex = 0;
    loopState.subStepStartTime = currentTime;
  }
  
  // 完成循环
  private static completeLoop(loopState: LoopState): void {
    loopState.isActive = false;
    loopState.isCompleted = true;
    loopState.nextExecutionTime = Infinity; // 永不再执行
  }
  
  // 暂停循环
  static pauseLoop(loopState: LoopState, currentTime: number): void {
    if (!loopState.isActive || loopState.isPaused) return;
    
    loopState.isPaused = true;
    loopState.pausedAt = currentTime;
  }
  
  // 恢复循环
  static resumeLoop(loopState: LoopState, currentTime: number): void {
    if (!loopState.isActive || !loopState.isPaused) return;
    
    const pauseDuration = currentTime - (loopState.pausedAt || 0);
    
    // 调整时间，补偿暂停期间的时间
    loopState.startTime += pauseDuration;
    loopState.nextExecutionTime += pauseDuration;
    
    loopState.isPaused = false;
    delete loopState.pausedAt;
  }
}
```

## 批量状态管理

### 多循环协调
```typescript
class BatchLoopManager {
  private loopStateManager: LoopStateManager;
  
  constructor(loopStateManager: LoopStateManager) {
    this.loopStateManager = loopStateManager;
  }
  
  // 批量初始化步骤中的所有循环
  initializeStepLoops(step: Step, stepStartTime: number, taskId: string, stepIndex: number): void {
    step.parallelLoops.forEach(loop => {
      this.loopStateManager.initializeLoop(loop, stepStartTime, taskId, stepIndex);
    });
  }
  
  // 获取当前需要执行的循环
  getDueLoops(currentTime: number): LoopState[] {
    return this.loopStateManager.getActiveLoops()
      .filter(loopState => LoopTimeCalculator.isLoopDue(loopState, currentTime));
  }
  
  // 检查步骤中的所有循环是否完成
  areStepLoopsCompleted(stepIndex: number): boolean {
    const stepLoops = Array.from(this.loopStateManager.loopStates.values())
      .filter(state => state.stepIndex === stepIndex);
    
    return stepLoops.every(state => state.isCompleted);
  }
  
  // 暂停步骤中的所有循环
  pauseStepLoops(stepIndex: number, currentTime: number): void {
    const stepLoops = Array.from(this.loopStateManager.loopStates.values())
      .filter(state => state.stepIndex === stepIndex && state.isActive);
    
    stepLoops.forEach(loopState => {
      LoopStateUpdater.pauseLoop(loopState, currentTime);
    });
  }
  
  // 恢复步骤中的所有循环
  resumeStepLoops(stepIndex: number, currentTime: number): void {
    const stepLoops = Array.from(this.loopStateManager.loopStates.values())
      .filter(state => state.stepIndex === stepIndex && state.isPaused);
    
    stepLoops.forEach(loopState => {
      LoopStateUpdater.resumeLoop(loopState, currentTime);
    });
  }
}
```

## 状态持久化

### 内存管理
```typescript
class LoopStateStorage {
  private static readonly MAX_COMPLETED_LOOPS = 1000; // 最多保留1000个已完成循环
  
  // 清理已完成的循环状态
  static cleanupCompletedLoops(loopStates: Map<string, LoopState>): void {
    const completedLoops = Array.from(loopStates.entries())
      .filter(([_, state]) => state.isCompleted)
      .sort((a, b) => a[1].lastExecutionTime - b[1].lastExecutionTime);
    
    // 保留最近的已完成循环，删除过旧的
    if (completedLoops.length > this.MAX_COMPLETED_LOOPS) {
      const toDelete = completedLoops.slice(0, completedLoops.length - this.MAX_COMPLETED_LOOPS);
      toDelete.forEach(([loopId]) => {
        loopStates.delete(loopId);
      });
    }
  }
  
  // 序列化循环状态
  static serializeLoopStates(loopStates: Map<string, LoopState>): string {
    const statesArray = Array.from(loopStates.entries());
    return JSON.stringify(statesArray);
  }
  
  // 反序列化循环状态
  static deserializeLoopStates(serialized: string): Map<string, LoopState> {
    const statesArray = JSON.parse(serialized);
    return new Map(statesArray);
  }
}
```

## 状态监控和调试

### 循环状态监控
```typescript
class LoopStateMonitor {
  // 生成循环状态报告
  static generateStatusReport(loopStates: Map<string, LoopState>): LoopStatusReport {
    const activeLoops = Array.from(loopStates.values()).filter(s => s.isActive);
    const pausedLoops = Array.from(loopStates.values()).filter(s => s.isPaused);
    const completedLoops = Array.from(loopStates.values()).filter(s => s.isCompleted);
    
    return {
      totalLoops: loopStates.size,
      activeLoops: activeLoops.length,
      pausedLoops: pausedLoops.length,
      completedLoops: completedLoops.length,
      averageProgress: this.calculateAverageProgress(activeLoops),
      nextExecutionTimes: activeLoops.map(s => ({
        loopId: s.loopId,
        nextTime: s.nextExecutionTime,
        timeUntilNext: s.nextExecutionTime - Date.now()
      }))
    };
  }
  
  // 计算平均进度
  private static calculateAverageProgress(activeLoops: LoopState[]): number {
    if (activeLoops.length === 0) return 1;
    
    const totalProgress = activeLoops.reduce((sum, loop) => {
      return sum + LoopTimeCalculator.calculateProgress(loop);
    }, 0);
    
    return totalProgress / activeLoops.length;
  }
  
  // 检测异常循环
  static detectAnomalousLoops(loopStates: Map<string, LoopState>, currentTime: number): string[] {
    const anomalies: string[] = [];
    
    for (const [loopId, state] of loopStates) {
      // 检测超时循环
      if (state.isActive && !state.isPaused) {
        const timeSinceLastExecution = currentTime - state.lastExecutionTime;
        if (timeSinceLastExecution > state.intervalMs * 2) {
          anomalies.push(`Loop ${loopId} appears stuck (${timeSinceLastExecution}ms since last execution)`);
        }
      }
      
      // 检测时间异常
      if (state.nextExecutionTime < state.lastExecutionTime) {
        anomalies.push(`Loop ${loopId} has invalid time sequence`);
      }
    }
    
    return anomalies;
  }
}
```

## 总结

循环状态管理模块的核心优势：

1. **独立状态跟踪** - 每个循环完全独立管理
2. **精确时间控制** - 基于绝对时间计算，避免累积误差
3. **动态控制能力** - 支持暂停、恢复、停止等操作
4. **内存高效管理** - 自动清理过期状态，控制内存使用
5. **异常检测** - 主动检测和报告异常状态
6. **批量操作支持** - 高效的多循环协调管理

这个模块确保了50个并行循环能够精确、独立、高效地运行，为整个任务编排器提供了坚实的状态管理基础。
