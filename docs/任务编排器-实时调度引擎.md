# 任务编排器 - 实时调度引擎

## 核心设计理念

实时调度引擎是任务编排器的心脏，负责：
1. **0.1s精度调度** - 确保动作在精确时间执行
2. **50个并行循环管理** - 独立跟踪每个循环状态
3. **真并行执行** - 同一时刻的动作批量发送Arduino
4. **内存高效** - 避免预展开，实时计算当前需要的动作

## 调度器架构设计

### 核心调度器类
```typescript
class TaskScheduler {
  private tickInterval = 100; // 100ms = 0.1s精度
  private timerId: NodeJS.Timeout | null = null;
  private executionState: TaskExecutionState | null = null;
  private deviceController: DeviceController;
  
  constructor(deviceController: DeviceController) {
    this.deviceController = deviceController;
  }
  
  // 启动任务执行
  startTask(task: Task): void {
    this.executionState = this.initializeExecutionState(task);
    this.startTicking();
  }
  
  // 核心调度循环 - 每100ms执行一次
  private tick(): void {
    if (!this.executionState) return;
    
    const currentTime = Date.now();
    const actions = this.calculateCurrentActions(currentTime);
    
    if (actions.length > 0) {
      // 批量发送动作到Arduino - 实现真并行
      this.deviceController.sendBatchCommands(actions);
    }
    
    // 更新执行状态
    this.updateExecutionState(currentTime);
    
    // 检查是否完成
    if (this.isTaskCompleted()) {
      this.stopTask();
    }
  }
}
```

### 实时动作计算算法
```typescript
// 核心算法：计算当前时刻需要执行的动作
private calculateCurrentActions(currentTime: number): Action[] {
  const actions: Action[] = [];
  const state = this.executionState!;
  const currentStep = state.task.steps[state.currentStepIndex];
  
  if (!currentStep) return actions;
  
  // 1. 检查步骤级别的普通动作（只在步骤开始时执行一次）
  if (this.isStepJustStarted(currentTime)) {
    actions.push(...this.processStepActions(currentStep.actions, currentTime));
  }

  // 2. 检查所有并行循环的当前子步骤动作
  for (const loop of currentStep.parallelLoops) {
    const loopState = state.loopStates.get(loop.id);
    if (loopState && this.isLoopSubStepDue(loopState, currentTime)) {
      actions.push(...this.processCurrentSubStepActions(loop, loopState, currentTime));
    }
  }

  // 3. 检查延时动作（延时到期后执行内容）
  actions.push(...this.processDelayActions(currentTime));
  
  return actions;
}
```

## 循环状态管理算法

### 循环时间计算
```typescript
// 计算循环的下次执行时间
private calculateNextLoopTime(loop: ParallelLoop, loopState: LoopState): number {
  // 循环开始时间 + (当前循环次数 * 循环间隔)
  return loopState.startTime + (loopState.currentIteration * loop.intervalMs);
}

// 检查循环是否到时间执行
private isLoopDue(loopState: LoopState, currentTime: number): boolean {
  return loopState.isActive && 
         !loopState.isPaused && 
         currentTime >= loopState.nextExecutionTime &&
         loopState.currentIteration < loopState.totalIterations;
}

// 处理循环的当前子步骤动作
private processCurrentSubStepActions(loop: ParallelLoop, loopState: LoopState, currentTime: number): Action[] {
  const actions: Action[] = [];

  // 只执行当前子步骤的动作（子步骤间串行）
  const currentSubStep = loop.subSteps[loopState.currentSubStepIndex];
  if (currentSubStep) {
    actions.push(...this.processStepActions(currentSubStep.actions, currentTime));
  }

  // 检查当前子步骤是否完成，决定是否推进
  this.checkAndAdvanceSubStep(loop, loopState, currentTime);

  return actions;
}

// 推进循环状态
private advanceLoopState(loop: ParallelLoop, loopState: LoopState): void {
  loopState.currentIteration++;
  loopState.nextExecutionTime = this.calculateNextLoopTime(loop, loopState);
  
  // 检查循环是否完成
  if (loopState.currentIteration >= loopState.totalIterations) {
    loopState.isActive = false;
  }
}
```

### 50个并行循环的独立管理
```typescript
// 初始化所有循环状态
private initializeLoopStates(step: Step, stepStartTime: number): Map<string, LoopState> {
  const loopStates = new Map<string, LoopState>();
  
  step.parallelLoops.forEach(loop => {
    loopStates.set(loop.id, {
      loopId: loop.id,
      currentIteration: 0,
      totalIterations: loop.iterations,
      nextExecutionTime: stepStartTime, // 立即开始
      startTime: stepStartTime,
      isActive: true,
      isPaused: false
    });
  });
  
  return loopStates;
}

// 检查所有循环是否完成
private areAllLoopsCompleted(loopStates: Map<string, LoopState>): boolean {
  for (const loopState of loopStates.values()) {
    if (loopState.isActive) {
      return false;
    }
  }
  return true;
}
```

## 延时动作处理

### 延时状态管理
```typescript
// 处理延时动作
private processDelayActions(currentTime: number): Action[] {
  const actions: Action[] = [];
  const state = this.executionState!;
  
  // 检查所有待触发的延时动作
  for (const [delayId, delayState] of state.delayStates) {
    if (!delayState.isTriggered && currentTime >= delayState.triggerTime) {
      // 延时到期，执行所有动作
      const delayAction = this.findDelayAction(delayId);
      if (delayAction) {
        actions.push(...delayAction.actions);
        delayState.isTriggered = true;
      }
    }
  }
  
  return actions;
}

// 注册延时动作
private registerDelayAction(delayAction: DelayAction, baseTime: number): void {
  const state = this.executionState!;
  state.delayStates.set(delayAction.id, {
    delayId: delayAction.id,
    triggerTime: baseTime + delayAction.delayMs,
    isTriggered: false
  });
}
```

## 步骤流转控制

### 步骤完成检测
```typescript
// 检查当前步骤是否完成
private isCurrentStepCompleted(): boolean {
  const state = this.executionState!;
  const currentStep = state.task.steps[state.currentStepIndex];
  
  if (!currentStep) return true;
  
  // 检查所有循环是否完成
  const allLoopsCompleted = this.areAllLoopsCompleted(state.loopStates);
  
  // 检查所有延时动作是否完成
  const allDelaysCompleted = this.areAllDelaysCompleted(state.delayStates);
  
  return allLoopsCompleted && allDelaysCompleted;
}

// 推进到下一步骤
private advanceToNextStep(): void {
  const state = this.executionState!;
  state.currentStepIndex++;
  
  if (state.currentStepIndex < state.task.steps.length) {
    // 初始化新步骤
    const nextStep = state.task.steps[state.currentStepIndex];
    const stepStartTime = Date.now();
    
    state.stepStartTime = stepStartTime;
    state.loopStates = this.initializeLoopStates(nextStep, stepStartTime);
    state.delayStates.clear();
    
    // 注册新步骤的延时动作
    this.registerStepDelayActions(nextStep, stepStartTime);
  }
}
```

## 性能优化策略

### 高精度定时器
```typescript
// 使用高精度定时器确保0.1s精度
private startTicking(): void {
  const targetInterval = this.tickInterval;
  let lastTickTime = Date.now();
  
  const tick = () => {
    const currentTime = Date.now();
    const actualInterval = currentTime - lastTickTime;
    
    // 执行调度逻辑
    this.tick();
    
    // 计算下次执行时间，补偿执行耗时
    const executionTime = Date.now() - currentTime;
    const nextInterval = Math.max(1, targetInterval - executionTime);
    
    this.timerId = setTimeout(tick, nextInterval);
    lastTickTime = currentTime;
  };
  
  this.timerId = setTimeout(tick, targetInterval);
}
```

### 批量命令优化
```typescript
// 批量发送命令到Arduino，实现真并行
async sendBatchCommands(actions: Action[]): Promise<void> {
  if (actions.length === 0) return;
  
  // 按设备分组命令
  const commandsByDevice = new Map<string, DeviceCommand[]>();
  
  actions.forEach(action => {
    if (!commandsByDevice.has(action.deviceId)) {
      commandsByDevice.set(action.deviceId, []);
    }
    commandsByDevice.get(action.deviceId)!.push({
      deviceId: action.deviceId,
      actionType: action.actionType,
      value: action.value,
      timestamp: Date.now()
    });
  });
  
  // 构建批量命令
  const batchCommand = {
    timestamp: Date.now(),
    commands: Array.from(commandsByDevice.values()).flat()
  };
  
  // 发送到Arduino
  await this.arduinoClient.sendBatchCommand(batchCommand);
}
```

## 实时状态广播

### WebSocket状态更新
```typescript
// 广播执行状态到前端
private broadcastExecutionState(): void {
  const state = this.executionState!;
  
  const statusUpdate = {
    type: 'task_execution_update',
    data: {
      taskId: state.task.id,
      currentStepIndex: state.currentStepIndex,
      totalSteps: state.task.steps.length,
      loopStates: Array.from(state.loopStates.entries()).map(([id, loopState]) => ({
        loopId: id,
        currentIteration: loopState.currentIteration,
        totalIterations: loopState.totalIterations,
        progress: loopState.currentIteration / loopState.totalIterations,
        isActive: loopState.isActive
      })),
      isRunning: state.isRunning,
      isPaused: state.isPaused
    }
  };
  
  this.websocketService.broadcast(statusUpdate);
}
```

## 错误处理和恢复

### 异常处理机制
```typescript
// 调度过程中的错误处理
private tick(): void {
  try {
    if (!this.executionState) return;
    
    const currentTime = Date.now();
    const actions = this.calculateCurrentActions(currentTime);
    
    if (actions.length > 0) {
      this.deviceController.sendBatchCommands(actions)
        .catch(error => this.handleCommandError(error, actions));
    }
    
    this.updateExecutionState(currentTime);
    this.broadcastExecutionState();
    
  } catch (error) {
    this.handleSchedulerError(error);
  }
}

// 命令发送失败处理
private handleCommandError(error: Error, failedActions: Action[]): void {
  console.error('Failed to send commands:', error);

  // 记录失败的动作（不进行重试，避免破坏编排逻辑）
  this.logFailedActions(failedActions);

  // 发送错误通知到前端
  this.notifyCommandFailure(failedActions, error);
}
```

## 总结

实时调度引擎的核心优势：

1. **精确时间控制** - 0.1s精度的调度循环
2. **真并行执行** - 同一时刻的动作批量发送
3. **高效状态管理** - 50个循环独立跟踪，O(1)查找
4. **内存优化** - 实时计算，避免预展开
5. **错误恢复** - 完善的异常处理机制
6. **实时反馈** - WebSocket状态广播

这个调度引擎能够完美处理您提到的"50个不同并行循环"的复杂场景，确保每个循环独立运行，同时保持0.1s的时间精度。
