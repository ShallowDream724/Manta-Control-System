# 任务编排器 - 前端编辑器模块

## 核心设计理念

前端编辑器模块负责提供直观、高效的任务编排界面，核心特点：
1. **可折叠结构** - 循环、延时等容器支持折叠/展开
2. **清晰的操作逻辑** - 用户能轻松理解串行/并行关系
3. **动态动作生成** - 根据设备配置动态生成可用动作
4. **严格的嵌套限制** - 前端不提供在子步骤中添加循环的选项
5. **实时验证** - 编辑过程中实时验证配置合理性

## 组件架构设计

### 主编辑器组件
```typescript
// 任务编辑器主组件
interface TaskEditorProps {
  task: Task | null;
  deviceConfigs: DeviceConfig[];
  onTaskChange: (task: Task) => void;
  onSave: (task: Task) => void;
}

const TaskEditor: React.FC<TaskEditorProps> = ({ task, deviceConfigs, onTaskChange, onSave }) => {
  const [editingTask, setEditingTask] = useState<Task>(task || createEmptyTask());
  const [validationErrors, setValidationErrors] = useState<string[]>([]);
  
  // 动态生成可用动作选项
  const availableActions = useMemo(() => 
    generateActionOptions(deviceConfigs), [deviceConfigs]
  );
  
  return (
    <div className="task-editor">
      <TaskHeader task={editingTask} onTaskInfoChange={handleTaskInfoChange} />
      <StepList 
        steps={editingTask.steps}
        availableActions={availableActions}
        onStepsChange={handleStepsChange}
      />
      <ValidationPanel errors={validationErrors} />
      <ActionButtons onSave={() => onSave(editingTask)} />
    </div>
  );
};
```

### 步骤列表组件
```typescript
// 步骤列表组件
interface StepListProps {
  steps: Step[];
  availableActions: ActionOption[];
  onStepsChange: (steps: Step[]) => void;
}

const StepList: React.FC<StepListProps> = ({ steps, availableActions, onStepsChange }) => {
  const handleAddStep = () => {
    const newStep = createEmptyStep();
    onStepsChange([...steps, newStep]);
  };
  
  const handleStepChange = (stepIndex: number, updatedStep: Step) => {
    const newSteps = [...steps];
    newSteps[stepIndex] = updatedStep;
    onStepsChange(newSteps);
  };
  
  return (
    <div className="step-list">
      {steps.map((step, index) => (
        <StepEditor
          key={step.id}
          step={step}
          stepIndex={index}
          availableActions={availableActions}
          onStepChange={(updatedStep) => handleStepChange(index, updatedStep)}
          onDeleteStep={() => handleDeleteStep(index)}
        />
      ))}
      <AddStepButton onClick={handleAddStep} />
    </div>
  );
};
```

## 步骤编辑器设计

### 步骤编辑组件
```typescript
// 步骤编辑器组件
interface StepEditorProps {
  step: Step;
  stepIndex: number;
  availableActions: ActionOption[];
  onStepChange: (step: Step) => void;
  onDeleteStep: () => void;
}

const StepEditor: React.FC<StepEditorProps> = ({ 
  step, stepIndex, availableActions, onStepChange, onDeleteStep 
}) => {
  const [isExpanded, setIsExpanded] = useState(true);
  
  return (
    <div className="step-editor border rounded-lg p-4 mb-4">
      <StepHeader 
        stepIndex={stepIndex}
        stepName={step.name}
        isExpanded={isExpanded}
        onToggleExpand={() => setIsExpanded(!isExpanded)}
        onNameChange={(name) => onStepChange({...step, name})}
        onDelete={onDeleteStep}
      />
      
      {isExpanded && (
        <div className="step-content mt-4">
          {/* 步骤内并行内容区域 */}
          <div className="parallel-content-notice mb-4 p-2 bg-blue-50 rounded">
            <span className="text-blue-700">
              📋 步骤内所有内容并行执行（同时开始）
            </span>
          </div>
          
          {/* 普通动作区域 */}
          <ActionSection
            title="普通动作"
            actions={step.actions}
            availableActions={availableActions}
            onActionsChange={(actions) => onStepChange({...step, actions})}
          />
          
          {/* 循环区域 */}
          <LoopSection
            title="并行循环"
            loops={step.parallelLoops}
            availableActions={availableActions}
            onLoopsChange={(loops) => onStepChange({...step, parallelLoops: loops})}
          />
        </div>
      )}
    </div>
  );
};
```

## 循环编辑器设计

### 可折叠循环组件
```typescript
// 循环编辑器组件
interface LoopEditorProps {
  loop: ParallelLoop;
  availableActions: ActionOption[];
  onLoopChange: (loop: ParallelLoop) => void;
  onDeleteLoop: () => void;
}

const LoopEditor: React.FC<LoopEditorProps> = ({ 
  loop, availableActions, onLoopChange, onDeleteLoop 
}) => {
  const [isExpanded, setIsExpanded] = useState(false); // 默认折叠
  
  return (
    <div className="loop-editor border-l-4 border-green-500 pl-4 mb-4">
      <LoopHeader
        loop={loop}
        isExpanded={isExpanded}
        onToggleExpand={() => setIsExpanded(!isExpanded)}
        onLoopConfigChange={(config) => onLoopChange({...loop, ...config})}
        onDelete={onDeleteLoop}
      />
      
      {isExpanded && (
        <div className="loop-content mt-4">
          {/* 循环配置 */}
          <LoopConfiguration
            iterations={loop.iterations}
            intervalMs={loop.intervalMs}
            onConfigChange={(config) => onLoopChange({...loop, ...config})}
          />
          
          {/* 子步骤串行提示 */}
          <div className="substep-notice mb-4 p-2 bg-yellow-50 rounded">
            <span className="text-yellow-700">
              🔄 子步骤串行执行（子步骤1完成后执行子步骤2）
            </span>
          </div>
          
          {/* 子步骤列表 */}
          <SubStepList
            subSteps={loop.subSteps}
            availableActions={availableActions}
            onSubStepsChange={(subSteps) => onLoopChange({...loop, subSteps})}
          />
        </div>
      )}
    </div>
  );
};
```

### 子步骤编辑器
```typescript
// 子步骤编辑器（逻辑与步骤编辑器相同，但不允许添加循环）
interface SubStepEditorProps {
  subStep: SubStep;
  subStepIndex: number;
  availableActions: ActionOption[];
  onSubStepChange: (subStep: SubStep) => void;
  onDeleteSubStep: () => void;
}

const SubStepEditor: React.FC<SubStepEditorProps> = ({ 
  subStep, subStepIndex, availableActions, onSubStepChange, onDeleteSubStep 
}) => {
  const [isExpanded, setIsExpanded] = useState(true);
  
  // 过滤掉循环选项（子步骤内不允许循环）
  const filteredActions = availableActions.filter(action => action.type !== 'loop');
  
  return (
    <div className="substep-editor border rounded p-3 mb-3 bg-gray-50">
      <SubStepHeader 
        subStepIndex={subStepIndex}
        subStepName={subStep.name}
        isExpanded={isExpanded}
        onToggleExpand={() => setIsExpanded(!isExpanded)}
        onNameChange={(name) => onSubStepChange({...subStep, name})}
        onDelete={onDeleteSubStep}
      />
      
      {isExpanded && (
        <div className="substep-content mt-3">
          {/* 子步骤内并行内容区域 */}
          <div className="parallel-content-notice mb-3 p-2 bg-green-50 rounded">
            <span className="text-green-700">
              📋 子步骤内所有内容并行执行
            </span>
          </div>
          
          {/* 只允许普通动作和延时，不允许循环 */}
          <ActionSection
            title="动作"
            actions={subStep.actions}
            availableActions={filteredActions}
            onActionsChange={(actions) => onSubStepChange({...subStep, actions})}
          />
        </div>
      )}
    </div>
  );
};
```

## 延时编辑器设计

### 可折叠延时容器
```typescript
// 延时动作编辑器
interface DelayEditorProps {
  delayAction: DelayAction;
  availableActions: ActionOption[];
  onDelayChange: (delayAction: DelayAction) => void;
  onDeleteDelay: () => void;
  nestingLevel: number; // 嵌套层级，用于样式区分
}

const DelayEditor: React.FC<DelayEditorProps> = ({ 
  delayAction, availableActions, onDelayChange, onDeleteDelay, nestingLevel 
}) => {
  const [isExpanded, setIsExpanded] = useState(false); // 默认折叠
  
  const borderColor = nestingLevel % 2 === 0 ? 'border-purple-500' : 'border-indigo-500';
  const bgColor = nestingLevel % 2 === 0 ? 'bg-purple-50' : 'bg-indigo-50';
  
  return (
    <div className={`delay-editor border-l-4 ${borderColor} pl-4 mb-4 ${bgColor} rounded`}>
      <DelayHeader
        delayAction={delayAction}
        isExpanded={isExpanded}
        onToggleExpand={() => setIsExpanded(!isExpanded)}
        onDelayConfigChange={(config) => onDelayChange({...delayAction, ...config})}
        onDelete={onDeleteDelay}
      />
      
      {isExpanded && (
        <div className="delay-content mt-4">
          {/* 延时配置 */}
          <DelayConfiguration
            delayMs={delayAction.delayMs}
            description={delayAction.description}
            onConfigChange={(config) => onDelayChange({...delayAction, ...config})}
          />
          
          {/* 延时后执行提示 */}
          <div className="delay-notice mb-4 p-2 bg-purple-100 rounded">
            <span className="text-purple-700">
              ⏰ 延时{delayAction.delayMs}ms后，以下内容并行执行
            </span>
          </div>
          
          {/* 延时内容（支持嵌套） */}
          <NestedActionSection
            title="延时后执行的内容"
            actions={delayAction.actions}
            availableActions={availableActions}
            nestingLevel={nestingLevel + 1}
            onActionsChange={(actions) => onDelayChange({...delayAction, actions})}
          />
        </div>
      )}
    </div>
  );
};
```

## 动作选择器设计

### 动态动作生成
```typescript
// 根据设备配置生成动作选项
function generateActionOptions(deviceConfigs: DeviceConfig[]): ActionOption[] {
  const options: ActionOption[] = [];
  
  // 添加设备控制动作
  deviceConfigs.forEach(device => {
    if (device.mode === 'pwm') {
      options.push({
        id: `${device.id}_power`,
        type: 'device_control',
        label: `${device.name} - 功率控制`,
        icon: '⚡',
        deviceId: device.id,
        actionType: 'power',
        valueType: 'number',
        valueRange: [0, device.maxPower || 100],
        unit: '%'
      });
    } else {
      options.push({
        id: `${device.id}_state`,
        type: 'device_control',
        label: `${device.name} - 开关控制`,
        icon: '🔘',
        deviceId: device.id,
        actionType: 'state',
        valueType: 'boolean'
      });
    }
  });
  
  // 添加默认容器动作
  options.push(
    {
      id: 'add_loop',
      type: 'loop',
      label: '添加循环',
      icon: '🔄',
      description: '创建并行循环容器'
    },
    {
      id: 'add_delay',
      type: 'delay',
      label: '添加延时',
      icon: '⏰',
      description: '创建延时容器'
    }
  );
  
  return options;
}

// 动作选择器组件
interface ActionSelectorProps {
  availableActions: ActionOption[];
  onActionSelect: (actionType: string) => void;
  allowedTypes?: string[]; // 允许的动作类型（用于子步骤限制）
}

const ActionSelector: React.FC<ActionSelectorProps> = ({ 
  availableActions, onActionSelect, allowedTypes 
}) => {
  const filteredActions = allowedTypes 
    ? availableActions.filter(action => allowedTypes.includes(action.type))
    : availableActions;
  
  return (
    <div className="action-selector grid grid-cols-2 md:grid-cols-3 gap-2">
      {filteredActions.map(action => (
        <button
          key={action.id}
          onClick={() => onActionSelect(action.type)}
          className="action-option p-3 border rounded-lg hover:bg-gray-50 text-left"
        >
          <div className="flex items-center space-x-2">
            <span className="text-xl">{action.icon}</span>
            <div>
              <div className="font-medium text-sm">{action.label}</div>
              {action.description && (
                <div className="text-xs text-gray-500">{action.description}</div>
              )}
            </div>
          </div>
        </button>
      ))}
    </div>
  );
};
```

## 实时验证系统

### 编辑时验证
```typescript
// 实时验证hook
function useTaskValidation(task: Task, deviceConfigs: DeviceConfig[]) {
  const [errors, setErrors] = useState<ValidationError[]>([]);
  const [warnings, setWarnings] = useState<ValidationWarning[]>([]);
  
  useEffect(() => {
    const validationResult = validateTask(task, deviceConfigs);
    setErrors(validationResult.errors);
    setWarnings(validationResult.warnings);
  }, [task, deviceConfigs]);
  
  return { errors, warnings, isValid: errors.length === 0 };
}

// 验证面板组件
interface ValidationPanelProps {
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

const ValidationPanel: React.FC<ValidationPanelProps> = ({ errors, warnings }) => {
  if (errors.length === 0 && warnings.length === 0) {
    return (
      <div className="validation-panel p-3 bg-green-50 border border-green-200 rounded">
        <span className="text-green-700">✅ 任务配置有效</span>
      </div>
    );
  }
  
  return (
    <div className="validation-panel space-y-2">
      {errors.map((error, index) => (
        <div key={index} className="error p-3 bg-red-50 border border-red-200 rounded">
          <span className="text-red-700">❌ {error.message}</span>
        </div>
      ))}
      {warnings.map((warning, index) => (
        <div key={index} className="warning p-3 bg-yellow-50 border border-yellow-200 rounded">
          <span className="text-yellow-700">⚠️ {warning.message}</span>
        </div>
      ))}
    </div>
  );
};
```

## 总结

前端编辑器模块的核心优势：

1. **直观的可视化编辑** - 清晰的折叠/展开界面
2. **严格的逻辑控制** - 前端层面防止错误嵌套
3. **动态内容生成** - 根据设备配置自动生成选项
4. **实时验证反馈** - 编辑过程中即时发现问题
5. **优秀的用户体验** - 清晰的串行/并行关系提示
6. **灵活的嵌套支持** - 支持延时容器的多层嵌套

这个编辑器确保用户能够轻松创建复杂的任务编排，同时避免逻辑错误。
