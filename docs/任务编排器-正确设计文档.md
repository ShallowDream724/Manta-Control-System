# 任务编排器 - 正确设计文档

## 核心理念澄清

### 任务编排器的本质
任务编排器就是一个**时间调度器**，唯一职责是：
**在正确的时间点发送正确的命令给Arduino**

### 关键概念澄清

#### 1. 并行执行的真实含义
- **步骤内并行** = 同一时刻发送多个命令给Arduino
- **子步骤内并行** = 同一时刻发送多个命令给Arduino
- **延时内并行** = 延时到期后，同一时刻发送多个命令给Arduino

#### 2. 时间计算的正确逻辑
- **动作持续时间** - 每个设备动作都有duration属性，表示持续多久
- **并行内容总时长** - Max(所有并行内容的完成时间)
- **循环间隔** - 一次循环结束后等待多久开始下一次循环
- **延时叠加** - 嵌套延时简单相加

#### 3. 循环的正确时序
```
循环1开始 → 执行所有子步骤 → 循环1结束 → 等待间隔时间 → 循环2开始
```

## 具体示例分析

### 示例：复杂步骤的时间计算

```
步骤1（第0秒开始）{
  // 立即执行（第0秒）
  充气泵1: 80%功率，10秒    // 0秒开始，10秒结束
  充气泵2: 60%功率，8秒     // 0秒开始，8秒结束
  
  // 延时5秒后执行（第5秒）
  延时5秒 {
    阀门1: 开启，持续2秒      // 5秒开始，7秒结束
    阀门2: 开启，持续3秒      // 5秒开始，8秒结束
    
    // 嵌套延时（5+2=7秒后执行）
    延时2秒 {
      抽气泵1: 100%功率，5秒  // 7秒开始，12秒结束
    }
  }
  
  // 并行循环（第0秒开始）
  循环5次，间隔10秒 {
    子步骤1 {
      充气泵1: 50%功率，3秒   // 并行，3秒完成
      充气泵2: 50%功率，3秒   // 并行，3秒完成
    }  // 子步骤1总时长：Max(3,3) = 3秒
    
    子步骤2 { // 在子步骤1完成后开始
      抽气泵1: 80%功率，2秒   // 并行，2秒完成
      
      延时1秒 { //延时的计时开始与抽气泵1打开同时
        阀门1: 开启，0.5秒     // 1秒后开始，1.5秒时候完成
      }
    }  // 子步骤2总时长：Max(2, 1+0.5) = 2秒
  }
  // 每次循环总时长：3秒 + 2秒 = 5秒
  // 循环时序：0秒开始 → 5秒结束 → 等待10秒 → 15秒开始第2次
}

// 步骤1总时长：Max(10秒, 8秒, 12秒, 循环总时长)
// 循环总时长：5次×(5秒+10秒间隔) - 10秒 = 65秒
// 步骤1总时长：Max(10, 8, 12, 65) = 65秒

//注意电脑端的时间线主要是发送命令，主要关注的是当前瞬间的并行，也要处理好串行，而定时任务意味着运行规定时长后关闭，定时任务的逻辑应该在arduino端实现。
```

## 数据结构设计

### 核心原则
1. **每个动作必须有duration** - 表示持续时间
2. **延时只是时间偏移** - 不改变内部的并行关系
3. **循环状态实时维护** - 不预展开，避免内存爆炸
4. **时间计算统一管理** - 所有时间逻辑集中处理

### 动作定义
```
Action {
  deviceId: 设备ID
  actionType: 'power' | 'state'
  value: 功率值或开关状态
  duration: 持续时间（毫秒）- 必须字段！
}
```

### 延时定义
```
DelayAction {
  delayMs: 延时时间
  actions: 延时后执行的内容（支持嵌套）
}
```

### 循环定义
```
ParallelLoop {
  iterations: 循环次数
  intervalMs: 循环间隔（结束后等待时间）
  subSteps: 子步骤列表（串行执行）
}
```

## 调度器设计原则

### 核心思路
1. **维护循环状态** - 不展开循环，实时计算当前应该执行什么
2. **事件驱动** - 只在需要的时候计算下一个事件
3. **批量发送** - 同一时刻的多个命令批量发送给Arduino
4. **内存高效** - 无论循环多少次，内存占用恒定

### 状态管理
```
LoopState {
  currentIteration: 当前循环次数
  currentSubStep: 当前子步骤索引
  nextExecutionTime: 下次执行时间
  // 不存储展开的内容！
}
```

### 延时管理
```
DelayState {
  triggerTime: 触发时间
  isTriggered: 是否已触发
  // 延时到期后，解析内容并发送命令
}
```

### Tick函数设计
```
每100ms执行一次：
1. 检查当前时间应该执行的循环
2. 检查当前时间应该触发的延时
3. 收集所有需要发送的命令
4. 批量发送给Arduino
5. 更新状态

注意：一次tick最多处理有限数量的事件，避免阻塞
```

## 关键错误避免

### 1. 不要展开循环
```
❌ 错误：for (let i = 0; i < 10000; i++) { 预计算事件 }
✅ 正确：维护循环状态，实时计算当前迭代
```

### 2. 不要混淆并行时间计算
```
❌ 错误：子步骤2时长 = 2秒 + 1秒 + 0.5秒 = 3.5秒
✅ 正确：子步骤2时长 = Max(2秒, 1秒+0.5秒) = 2秒
```

### 3. 不要混淆循环间隔
```
❌ 错误：intervalMs是循环周期
✅ 正确：intervalMs是循环结束后的等待时间
```

### 4. 不要在tick中处理过多事件
```
❌ 错误：while (有事件) { 处理事件 } // 可能阻塞
✅ 正确：每次tick最多处理N个事件
```

### 5. 不要忘记动作持续时间
```
❌ 错误：Action没有duration字段
✅ 正确：每个Action都必须有duration
```

## 性能考虑

### 内存优化
- 循环状态占用固定内存，与循环次数无关
- 延时状态按需创建，触发后清理
- 定期清理已完成的状态

### 时间精度
- 100ms的tick间隔足够精确
- 使用绝对时间计算，避免累积误差
- 时间漂移检测和补偿

### 并发处理
- 同一时刻的命令批量发送
- Arduino端并行处理多个设备
- 避免频繁的单个命令发送

## 总结

任务编排器的核心就是：
1. **正确理解并行和串行的含义**
2. **正确计算时间和持续时间**
3. **维护状态而不是展开数据**
4. **在正确的时间发送正确的命令**

一切复杂的逻辑都围绕这个核心展开，不要被表面的复杂性迷惑。
