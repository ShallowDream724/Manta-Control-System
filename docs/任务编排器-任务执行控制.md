# 任务编排器 - 任务执行控制模块

## 核心设计理念

任务执行控制模块是任务编排器的控制中心，负责：
1. **任务生命周期管理** - 启动、暂停、恢复、停止任务
2. **执行状态监控** - 实时跟踪任务执行进度
3. **异常处理** - 处理执行过程中的各种异常情况
4. **资源管理** - 管理任务执行所需的系统资源
5. **并发控制** - 确保同时只有一个任务在执行

## 任务执行控制器

### 主控制器类
```typescript
// 任务执行控制器
class TaskExecutionController {
  private scheduler: TaskScheduler;
  private connectionManager: ArduinoConnectionManager;
  private websocketService: WebSocketService;
  private currentExecution: TaskExecution | null = null;
  private executionHistory: TaskExecution[] = [];
  
  constructor(
    scheduler: TaskScheduler,
    connectionManager: ArduinoConnectionManager,
    websocketService: WebSocketService
  ) {
    this.scheduler = scheduler;
    this.connectionManager = connectionManager;
    this.websocketService = websocketService;
  }
  
  // 启动任务执行
  async startTask(task: Task): Promise<TaskExecution> {
    // 检查是否有任务正在执行
    if (this.currentExecution && this.currentExecution.status === 'running') {
      throw new Error('Another task is already running');
    }
    
    // 检查Arduino连接
    if (!this.connectionManager.isConnected()) {
      throw new Error('Arduino not connected');
    }
    
    // 验证任务配置
    const validationResult = this.validateTask(task);
    if (!validationResult.isValid) {
      throw new Error(`Task validation failed: ${validationResult.errors.join(', ')}`);
    }
    
    // 创建执行实例
    const execution = this.createTaskExecution(task);
    this.currentExecution = execution;
    
    try {
      // 启动调度器
      await this.scheduler.startTask(task);
      
      // 更新执行状态
      execution.status = 'running';
      execution.startTime = Date.now();
      
      // 广播执行开始事件
      this.broadcastExecutionEvent('task_started', execution);
      
      return execution;
      
    } catch (error) {
      execution.status = 'failed';
      execution.error = error.message;
      throw error;
    }
  }
  
  // 暂停任务执行
  async pauseTask(): Promise<void> {
    if (!this.currentExecution || this.currentExecution.status !== 'running') {
      throw new Error('No running task to pause');
    }
    
    try {
      await this.scheduler.pauseTask();
      
      this.currentExecution.status = 'paused';
      this.currentExecution.pausedAt = Date.now();
      
      this.broadcastExecutionEvent('task_paused', this.currentExecution);
      
    } catch (error) {
      throw new Error(`Failed to pause task: ${error.message}`);
    }
  }
  
  // 恢复任务执行
  async resumeTask(): Promise<void> {
    if (!this.currentExecution || this.currentExecution.status !== 'paused') {
      throw new Error('No paused task to resume');
    }
    
    try {
      await this.scheduler.resumeTask();
      
      // 计算暂停时长
      const pauseDuration = Date.now() - (this.currentExecution.pausedAt || 0);
      this.currentExecution.totalPausedTime += pauseDuration;
      
      this.currentExecution.status = 'running';
      this.currentExecution.pausedAt = undefined;
      
      this.broadcastExecutionEvent('task_resumed', this.currentExecution);
      
    } catch (error) {
      throw new Error(`Failed to resume task: ${error.message}`);
    }
  }
  
  // 停止任务执行
  async stopTask(): Promise<void> {
    if (!this.currentExecution) {
      throw new Error('No task to stop');
    }
    
    try {
      await this.scheduler.stopTask();
      
      this.currentExecution.status = 'stopped';
      this.currentExecution.endTime = Date.now();
      
      // 添加到历史记录
      this.executionHistory.push(this.currentExecution);
      
      this.broadcastExecutionEvent('task_stopped', this.currentExecution);
      
      this.currentExecution = null;
      
    } catch (error) {
      throw new Error(`Failed to stop task: ${error.message}`);
    }
  }
}
```

## 任务执行状态管理

### 执行状态数据结构
```typescript
// 任务执行实例
interface TaskExecution {
  id: string;                    // 执行ID
  taskId: string;                // 任务ID
  taskName: string;              // 任务名称
  status: ExecutionStatus;       // 执行状态
  startTime?: number;            // 开始时间
  endTime?: number;              // 结束时间
  pausedAt?: number;             // 暂停时间
  totalPausedTime: number;       // 总暂停时长
  currentStepIndex: number;      // 当前步骤索引
  totalSteps: number;            // 总步骤数
  progress: number;              // 执行进度 (0-1)
  loopStates: LoopExecutionState[]; // 循环执行状态
  error?: string;                // 错误信息
  createdBy: string;             // 创建者
}

// 执行状态枚举
type ExecutionStatus = 'pending' | 'running' | 'paused' | 'completed' | 'failed' | 'stopped';

// 循环执行状态
interface LoopExecutionState {
  loopId: string;
  loopName: string;
  currentIteration: number;
  totalIterations: number;
  progress: number;
  isActive: boolean;
  isPaused: boolean;
}
```

### 状态更新管理器
```typescript
// 执行状态更新管理器
class ExecutionStateManager {
  private currentExecution: TaskExecution | null = null;
  private stateUpdateInterval: NodeJS.Timeout | null = null;
  
  // 开始状态更新
  startStateUpdates(execution: TaskExecution, scheduler: TaskScheduler) {
    this.currentExecution = execution;
    
    // 每100ms更新一次状态
    this.stateUpdateInterval = setInterval(() => {
      this.updateExecutionState(scheduler);
    }, 100);
  }
  
  // 停止状态更新
  stopStateUpdates() {
    if (this.stateUpdateInterval) {
      clearInterval(this.stateUpdateInterval);
      this.stateUpdateInterval = null;
    }
    this.currentExecution = null;
  }
  
  // 更新执行状态
  private updateExecutionState(scheduler: TaskScheduler) {
    if (!this.currentExecution) return;
    
    const schedulerState = scheduler.getExecutionState();
    if (!schedulerState) return;
    
    // 更新基本状态
    this.currentExecution.currentStepIndex = schedulerState.currentStepIndex;
    this.currentExecution.progress = this.calculateProgress(schedulerState);
    
    // 更新循环状态
    this.currentExecution.loopStates = this.extractLoopStates(schedulerState);
    
    // 检查是否完成
    if (this.isTaskCompleted(schedulerState)) {
      this.completeTask();
    }
  }
  
  // 计算总体进度
  private calculateProgress(state: TaskExecutionState): number {
    const stepProgress = state.currentStepIndex / state.task.steps.length;
    
    // 加上当前步骤内的循环进度
    const currentStepLoopProgress = this.calculateStepLoopProgress(state);
    const stepWeight = 1 / state.task.steps.length;
    
    return Math.min(stepProgress + (currentStepLoopProgress * stepWeight), 1);
  }
  
  // 计算当前步骤的循环进度
  private calculateStepLoopProgress(state: TaskExecutionState): number {
    const activeLoops = Array.from(state.loopStates.values())
      .filter(loop => loop.isActive);
    
    if (activeLoops.length === 0) return 1;
    
    const totalProgress = activeLoops.reduce((sum, loop) => {
      return sum + (loop.currentIteration / loop.totalIterations);
    }, 0);
    
    return totalProgress / activeLoops.length;
  }
  
  // 完成任务
  private completeTask() {
    if (!this.currentExecution) return;
    
    this.currentExecution.status = 'completed';
    this.currentExecution.endTime = Date.now();
    this.currentExecution.progress = 1;
    
    this.stopStateUpdates();
  }
}
```

## 并发控制和资源管理

### 任务队列管理
```typescript
// 任务队列管理器
class TaskQueueManager {
  private executionQueue: TaskExecution[] = [];
  private maxConcurrentTasks: number = 1; // 同时只允许一个任务执行
  private isProcessing: boolean = false;
  
  // 添加任务到队列
  enqueueTask(task: Task, priority: number = 0): string {
    const execution = {
      id: generateId(),
      taskId: task.id,
      taskName: task.name,
      status: 'pending' as ExecutionStatus,
      priority,
      queuedAt: Date.now(),
      // ... 其他字段
    };
    
    // 按优先级插入队列
    const insertIndex = this.findInsertPosition(priority);
    this.executionQueue.splice(insertIndex, 0, execution);
    
    // 尝试处理队列
    this.processQueue();
    
    return execution.id;
  }
  
  // 处理队列
  private async processQueue() {
    if (this.isProcessing || this.executionQueue.length === 0) {
      return;
    }
    
    this.isProcessing = true;
    
    try {
      while (this.executionQueue.length > 0 && this.canExecuteMore()) {
        const execution = this.executionQueue.shift()!;
        await this.executeTask(execution);
      }
    } finally {
      this.isProcessing = false;
    }
  }
  
  // 检查是否可以执行更多任务
  private canExecuteMore(): boolean {
    const runningTasks = this.executionQueue.filter(e => e.status === 'running');
    return runningTasks.length < this.maxConcurrentTasks;
  }
  
  // 取消队列中的任务
  cancelQueuedTask(executionId: string): boolean {
    const index = this.executionQueue.findIndex(e => e.id === executionId);
    if (index >= 0 && this.executionQueue[index].status === 'pending') {
      this.executionQueue[index].status = 'stopped';
      this.executionQueue.splice(index, 1);
      return true;
    }
    return false;
  }
}
```

### 资源锁管理
```typescript
// 资源锁管理器
class ResourceLockManager {
  private deviceLocks = new Map<string, string>(); // deviceId -> executionId
  private lockTimeouts = new Map<string, NodeJS.Timeout>();
  
  // 尝试锁定设备
  tryLockDevices(executionId: string, deviceIds: string[]): boolean {
    // 检查是否有设备已被锁定
    for (const deviceId of deviceIds) {
      if (this.deviceLocks.has(deviceId)) {
        return false;
      }
    }
    
    // 锁定所有设备
    for (const deviceId of deviceIds) {
      this.deviceLocks.set(deviceId, executionId);
      
      // 设置锁定超时（防止死锁）
      const timeout = setTimeout(() => {
        this.unlockDevice(deviceId);
      }, 300000); // 5分钟超时
      
      this.lockTimeouts.set(deviceId, timeout);
    }
    
    return true;
  }
  
  // 释放设备锁
  unlockDevices(executionId: string) {
    for (const [deviceId, lockedBy] of this.deviceLocks) {
      if (lockedBy === executionId) {
        this.unlockDevice(deviceId);
      }
    }
  }
  
  // 释放单个设备锁
  private unlockDevice(deviceId: string) {
    this.deviceLocks.delete(deviceId);
    
    const timeout = this.lockTimeouts.get(deviceId);
    if (timeout) {
      clearTimeout(timeout);
      this.lockTimeouts.delete(deviceId);
    }
  }
  
  // 检查设备是否被锁定
  isDeviceLocked(deviceId: string): boolean {
    return this.deviceLocks.has(deviceId);
  }
  
  // 获取设备锁定信息
  getDeviceLockInfo(deviceId: string): string | null {
    return this.deviceLocks.get(deviceId) || null;
  }
}
```

## 异常处理和恢复

### 异常处理器
```typescript
// 任务执行异常处理器
class TaskExecutionErrorHandler {
  private executionController: TaskExecutionController;
  private logger: Logger;
  
  constructor(controller: TaskExecutionController, logger: Logger) {
    this.executionController = controller;
    this.logger = logger;
  }
  
  // 处理Arduino连接异常
  handleArduinoConnectionError(execution: TaskExecution, error: Error) {
    this.logger.error(`Arduino connection error in task ${execution.id}:`, error);
    
    // 暂停任务执行
    execution.status = 'paused';
    execution.error = `Arduino连接异常: ${error.message}`;
    
    // 通知前端
    this.notifyExecutionError(execution, 'arduino_connection_error', error);
    
    // 尝试重连（不进行重试，避免破坏编排）
    this.scheduleConnectionCheck(execution);
  }
  
  // 处理命令执行异常
  handleCommandExecutionError(execution: TaskExecution, failedCommands: DeviceCommand[], error: Error) {
    this.logger.error(`Command execution error in task ${execution.id}:`, error);
    
    // 记录失败的命令
    this.logFailedCommands(execution, failedCommands, error);
    
    // 通知前端但不停止任务（让用户决定是否继续）
    this.notifyExecutionError(execution, 'command_execution_error', error);
  }
  
  // 处理任务超时
  handleTaskTimeout(execution: TaskExecution) {
    this.logger.warn(`Task ${execution.id} execution timeout`);
    
    execution.status = 'failed';
    execution.error = '任务执行超时';
    execution.endTime = Date.now();
    
    // 强制停止任务
    this.executionController.forceStopTask(execution.id);
    
    this.notifyExecutionError(execution, 'task_timeout', new Error('Task timeout'));
  }
  
  // 处理内存不足异常
  handleMemoryError(execution: TaskExecution, error: Error) {
    this.logger.error(`Memory error in task ${execution.id}:`, error);
    
    // 立即停止任务
    execution.status = 'failed';
    execution.error = `内存不足: ${error.message}`;
    
    this.executionController.forceStopTask(execution.id);
    this.notifyExecutionError(execution, 'memory_error', error);
  }
  
  private notifyExecutionError(execution: TaskExecution, errorType: string, error: Error) {
    // 通过WebSocket通知前端
    const errorEvent = {
      type: 'task_execution_error',
      data: {
        executionId: execution.id,
        errorType,
        error: error.message,
        timestamp: Date.now()
      }
    };
    
    // 发送错误通知
    this.executionController.broadcastEvent(errorEvent);
  }
  
  private scheduleConnectionCheck(execution: TaskExecution) {
    // 每5秒检查一次连接状态
    const checkInterval = setInterval(() => {
      if (this.executionController.connectionManager.isConnected()) {
        clearInterval(checkInterval);
        
        // 连接恢复，询问用户是否继续
        this.notifyConnectionRestored(execution);
      }
    }, 5000);
    
    // 最多检查5分钟
    setTimeout(() => {
      clearInterval(checkInterval);
    }, 300000);
  }
  
  private notifyConnectionRestored(execution: TaskExecution) {
    const event = {
      type: 'arduino_connection_restored',
      data: {
        executionId: execution.id,
        message: 'Arduino连接已恢复，是否继续执行任务？'
      }
    };
    
    this.executionController.broadcastEvent(event);
  }
}
```

## 执行历史和统计

### 执行历史管理
```typescript
// 执行历史管理器
class ExecutionHistoryManager {
  private history: TaskExecution[] = [];
  private maxHistorySize: number = 1000;
  
  // 添加执行记录
  addExecution(execution: TaskExecution) {
    this.history.unshift(execution);
    
    // 限制历史记录大小
    if (this.history.length > this.maxHistorySize) {
      this.history = this.history.slice(0, this.maxHistorySize);
    }
  }
  
  // 获取执行历史
  getHistory(limit?: number): TaskExecution[] {
    return limit ? this.history.slice(0, limit) : [...this.history];
  }
  
  // 获取执行统计
  getExecutionStats(): ExecutionStats {
    const total = this.history.length;
    const completed = this.history.filter(e => e.status === 'completed').length;
    const failed = this.history.filter(e => e.status === 'failed').length;
    const stopped = this.history.filter(e => e.status === 'stopped').length;
    
    const avgDuration = this.calculateAverageDuration();
    const successRate = total > 0 ? (completed / total) * 100 : 0;
    
    return {
      total,
      completed,
      failed,
      stopped,
      successRate,
      avgDuration
    };
  }
  
  private calculateAverageDuration(): number {
    const completedExecutions = this.history.filter(e => 
      e.status === 'completed' && e.startTime && e.endTime
    );
    
    if (completedExecutions.length === 0) return 0;
    
    const totalDuration = completedExecutions.reduce((sum, e) => {
      return sum + (e.endTime! - e.startTime! - e.totalPausedTime);
    }, 0);
    
    return totalDuration / completedExecutions.length;
  }
}
```

## 总结

任务执行控制模块的核心优势：

1. **完整的生命周期管理** - 启动、暂停、恢复、停止的完整控制
2. **实时状态监控** - 精确跟踪任务和循环执行进度
3. **强大的异常处理** - 各种异常情况的妥善处理
4. **资源管理** - 设备锁定和并发控制
5. **执行历史** - 完整的执行记录和统计分析
6. **用户友好** - 清晰的状态反馈和错误提示

这个控制模块为整个任务编排器提供了可靠的执行保障，确保任务能够按预期稳定运行。
