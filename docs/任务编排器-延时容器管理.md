# 任务编排器 - 延时容器管理模块

## 核心设计理念

延时容器是任务编排器中的特殊动作类型，具有以下特点：
1. **容器性质** - 可以包含多个子动作
2. **延时触发** - 在指定延时后执行所有子动作
3. **并行执行** - 延时到期后，所有子动作同时执行
4. **嵌套支持** - 延时容器内可以包含其他延时容器
5. **可折叠显示** - 前端界面中可折叠展示

## 延时容器数据结构

### 核心数据定义
```typescript
// 延时动作容器
interface DelayAction {
  id: string;
  type: 'delay';
  name: string;                    // 延时容器名称
  delayMs: number;                 // 延时毫秒数
  actions: (Action | DelayAction)[]; // 子动作列表（支持嵌套）
  description?: string;            // 延时描述
}

// 延时状态跟踪
interface DelayState {
  delayId: string;                 // 延时动作ID
  parentContext: string;           // 父级上下文（步骤ID或循环ID）
  triggerTime: number;             // 触发时间戳
  registeredTime: number;          // 注册时间戳
  isTriggered: boolean;            // 是否已触发
  isCompleted: boolean;            // 是否已完成
  childDelayIds: string[];         // 子延时动作ID列表
}
```

### 延时管理器类
```typescript
class DelayActionManager {
  private delayStates = new Map<string, DelayState>();
  private pendingDelays = new Set<string>();
  private completedDelays = new Set<string>();
  
  // 注册延时动作
  registerDelayAction(
    delayAction: DelayAction, 
    baseTime: number, 
    parentContext: string
  ): void {
    const triggerTime = baseTime + delayAction.delayMs;
    
    const delayState: DelayState = {
      delayId: delayAction.id,
      parentContext,
      triggerTime,
      registeredTime: baseTime,
      isTriggered: false,
      isCompleted: false,
      childDelayIds: []
    };
    
    this.delayStates.set(delayAction.id, delayState);
    this.pendingDelays.add(delayAction.id);
    
    // 递归注册嵌套的延时动作
    this.registerNestedDelays(delayAction.actions, triggerTime, delayAction.id);
  }
  
  // 递归注册嵌套延时
  private registerNestedDelays(
    actions: (Action | DelayAction)[], 
    baseTime: number, 
    parentDelayId: string
  ): void {
    actions.forEach(action => {
      if (action.type === 'delay') {
        this.registerDelayAction(action, baseTime, parentDelayId);
        
        // 记录父子关系
        const parentState = this.delayStates.get(parentDelayId);
        if (parentState) {
          parentState.childDelayIds.push(action.id);
        }
      }
    });
  }
}
```

## 延时触发算法

### 时间检测和触发
```typescript
class DelayTriggerEngine {
  private delayManager: DelayActionManager;
  
  constructor(delayManager: DelayActionManager) {
    this.delayManager = delayManager;
  }
  
  // 检查并触发到期的延时动作
  checkAndTriggerDelays(currentTime: number): Action[] {
    const triggeredActions: Action[] = [];
    const delaysToTrigger: string[] = [];
    
    // 检查所有待触发的延时
    for (const delayId of this.delayManager.pendingDelays) {
      const delayState = this.delayManager.delayStates.get(delayId);
      if (delayState && this.isDelayDue(delayState, currentTime)) {
        delaysToTrigger.push(delayId);
      }
    }
    
    // 触发到期的延时动作
    delaysToTrigger.forEach(delayId => {
      const actions = this.triggerDelayAction(delayId, currentTime);
      triggeredActions.push(...actions);
    });
    
    return triggeredActions;
  }
  
  // 检查延时是否到期
  private isDelayDue(delayState: DelayState, currentTime: number): boolean {
    return !delayState.isTriggered && 
           currentTime >= delayState.triggerTime;
  }
  
  // 触发延时动作
  private triggerDelayAction(delayId: string, currentTime: number): Action[] {
    const delayState = this.delayManager.delayStates.get(delayId);
    const delayAction = this.findDelayAction(delayId);
    
    if (!delayState || !delayAction || delayState.isTriggered) {
      return [];
    }
    
    // 标记为已触发
    delayState.isTriggered = true;
    this.delayManager.pendingDelays.delete(delayId);
    
    // 提取并返回所有非延时动作
    const immediateActions = this.extractImmediateActions(delayAction.actions);
    
    // 注册新的嵌套延时动作
    this.registerNestedDelaysFromTrigger(delayAction.actions, currentTime, delayId);
    
    return immediateActions;
  }
  
  // 提取立即执行的动作（非延时动作）
  private extractImmediateActions(actions: (Action | DelayAction)[]): Action[] {
    return actions.filter(action => action.type !== 'delay') as Action[];
  }
  
  // 从触发的延时中注册新的嵌套延时
  private registerNestedDelaysFromTrigger(
    actions: (Action | DelayAction)[], 
    triggerTime: number, 
    parentDelayId: string
  ): void {
    actions.forEach(action => {
      if (action.type === 'delay') {
        this.delayManager.registerDelayAction(action, triggerTime, parentDelayId);
      }
    });
  }
}
```

## 嵌套延时处理

### 多层嵌套管理
```typescript
class NestedDelayManager {
  // 计算嵌套延时的总延时时间
  static calculateTotalDelay(delayAction: DelayAction): number {
    let maxDelay = delayAction.delayMs;
    
    // 递归计算嵌套延时的最大延时
    delayAction.actions.forEach(action => {
      if (action.type === 'delay') {
        const nestedDelay = delayAction.delayMs + this.calculateTotalDelay(action);
        maxDelay = Math.max(maxDelay, nestedDelay);
      }
    });
    
    return maxDelay;
  }
  
  // 展平嵌套延时结构（用于预览）
  static flattenDelayStructure(delayAction: DelayAction, baseDelay = 0): DelayTimelineItem[] {
    const timeline: DelayTimelineItem[] = [];
    
    // 添加当前延时的动作
    const immediateActions = delayAction.actions.filter(a => a.type !== 'delay') as Action[];
    if (immediateActions.length > 0) {
      timeline.push({
        time: baseDelay + delayAction.delayMs,
        actions: immediateActions,
        delayName: delayAction.name
      });
    }
    
    // 递归处理嵌套延时
    delayAction.actions.forEach(action => {
      if (action.type === 'delay') {
        const nestedTimeline = this.flattenDelayStructure(
          action, 
          baseDelay + delayAction.delayMs
        );
        timeline.push(...nestedTimeline);
      }
    });
    
    return timeline.sort((a, b) => a.time - b.time);
  }
  
  // 验证嵌套延时的合理性
  static validateDelayNesting(delayAction: DelayAction, maxDepth = 5): ValidationResult {
    const errors: string[] = [];
    
    function validateRecursive(action: DelayAction, currentDepth: number, path: string): void {
      if (currentDepth > maxDepth) {
        errors.push(`延时嵌套过深: ${path} (最大深度: ${maxDepth})`);
        return;
      }
      
      action.actions.forEach((subAction, index) => {
        if (subAction.type === 'delay') {
          const subPath = `${path} → ${subAction.name}`;
          validateRecursive(subAction, currentDepth + 1, subPath);
        }
      });
    }
    
    validateRecursive(delayAction, 1, delayAction.name);
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}
```

## 延时状态同步

### 状态更新和清理
```typescript
class DelayStateManager {
  private delayStates: Map<string, DelayState>;
  
  constructor(delayStates: Map<string, DelayState>) {
    this.delayStates = delayStates;
  }
  
  // 更新延时完成状态
  markDelayCompleted(delayId: string): void {
    const delayState = this.delayStates.get(delayId);
    if (delayState) {
      delayState.isCompleted = true;
      
      // 检查是否所有子延时也已完成
      const allChildrenCompleted = delayState.childDelayIds.every(childId => {
        const childState = this.delayStates.get(childId);
        return childState?.isCompleted || false;
      });
      
      if (allChildrenCompleted) {
        this.notifyDelayChainCompleted(delayId);
      }
    }
  }
  
  // 检查上下文中的所有延时是否完成
  areContextDelaysCompleted(parentContext: string): boolean {
    const contextDelays = Array.from(this.delayStates.values())
      .filter(state => state.parentContext === parentContext);
    
    return contextDelays.every(state => state.isCompleted);
  }
  
  // 清理已完成的延时状态
  cleanupCompletedDelays(): void {
    const completedDelays = Array.from(this.delayStates.entries())
      .filter(([_, state]) => state.isCompleted)
      .map(([delayId]) => delayId);
    
    // 保留最近的100个已完成延时，删除其余的
    if (completedDelays.length > 100) {
      const toDelete = completedDelays
        .sort((a, b) => {
          const stateA = this.delayStates.get(a)!;
          const stateB = this.delayStates.get(b)!;
          return stateA.triggerTime - stateB.triggerTime;
        })
        .slice(0, completedDelays.length - 100);
      
      toDelete.forEach(delayId => {
        this.delayStates.delete(delayId);
      });
    }
  }
  
  // 通知延时链完成
  private notifyDelayChainCompleted(delayId: string): void {
    // 可以在这里添加回调或事件发射
    console.log(`Delay chain completed: ${delayId}`);
  }
}
```

## 延时可视化支持

### 前端预览数据生成
```typescript
class DelayVisualizationHelper {
  // 生成延时预览数据
  static generateDelayPreview(delayAction: DelayAction): DelayPreviewData {
    const timeline = NestedDelayManager.flattenDelayStructure(delayAction);
    const totalDuration = NestedDelayManager.calculateTotalDelay(delayAction);
    
    return {
      delayId: delayAction.id,
      name: delayAction.name,
      totalDuration,
      timeline,
      structure: this.buildDelayTree(delayAction)
    };
  }
  
  // 构建延时树结构（用于可折叠显示）
  private static buildDelayTree(delayAction: DelayAction): DelayTreeNode {
    const immediateActions = delayAction.actions.filter(a => a.type !== 'delay') as Action[];
    const nestedDelays = delayAction.actions.filter(a => a.type === 'delay') as DelayAction[];
    
    return {
      id: delayAction.id,
      name: delayAction.name,
      delayMs: delayAction.delayMs,
      immediateActions,
      children: nestedDelays.map(nested => this.buildDelayTree(nested)),
      isCollapsed: true // 默认折叠
    };
  }
  
  // 生成延时执行时间线
  static generateExecutionTimeline(
    delayActions: DelayAction[], 
    baseTime: number
  ): TimelineEvent[] {
    const events: TimelineEvent[] = [];
    
    delayActions.forEach(delayAction => {
      const timeline = NestedDelayManager.flattenDelayStructure(delayAction);
      timeline.forEach(item => {
        events.push({
          time: baseTime + item.time,
          type: 'delay_trigger',
          delayName: item.delayName,
          actions: item.actions,
          source: delayAction.id
        });
      });
    });
    
    return events.sort((a, b) => a.time - b.time);
  }
}
```

## 延时性能优化

### 高效触发检测
```typescript
class DelayPerformanceOptimizer {
  private sortedDelays: DelayState[] = [];
  private lastCheckTime = 0;
  
  // 维护按触发时间排序的延时列表
  updateSortedDelays(delayStates: Map<string, DelayState>): void {
    this.sortedDelays = Array.from(delayStates.values())
      .filter(state => !state.isTriggered && !state.isCompleted)
      .sort((a, b) => a.triggerTime - b.triggerTime);
  }
  
  // 优化的延时检测（只检查可能到期的延时）
  getDelaysDue(currentTime: number): DelayState[] {
    const dueDelays: DelayState[] = [];
    
    // 由于已排序，只需检查到第一个未到期的延时
    for (const delayState of this.sortedDelays) {
      if (delayState.triggerTime <= currentTime) {
        dueDelays.push(delayState);
      } else {
        // 后续延时都未到期，可以停止检查
        break;
      }
    }
    
    return dueDelays;
  }
  
  // 预测下次需要检查的时间
  getNextCheckTime(): number {
    if (this.sortedDelays.length === 0) {
      return Infinity;
    }
    return this.sortedDelays[0].triggerTime;
  }
}
```

## 错误处理和恢复

### 延时异常处理
```typescript
class DelayErrorHandler {
  // 处理延时触发异常
  static handleDelayTriggerError(delayId: string, error: Error): void {
    console.error(`Failed to trigger delay ${delayId}:`, error);

    // 记录错误但不阻止其他延时的执行
    this.logDelayError(delayId, error);

    // 不进行重试，避免破坏时间编排逻辑
    this.notifyDelayFailure(delayId, error);
  }
  
  // 检测延时状态异常
  static detectDelayAnomalies(delayStates: Map<string, DelayState>, currentTime: number): string[] {
    const anomalies: string[] = [];
    
    for (const [delayId, state] of delayStates) {
      // 检测过期未触发的延时
      if (!state.isTriggered && currentTime > state.triggerTime + 1000) {
        anomalies.push(`Delay ${delayId} is overdue by ${currentTime - state.triggerTime}ms`);
      }
      
      // 检测时间异常
      if (state.triggerTime < state.registeredTime) {
        anomalies.push(`Delay ${delayId} has invalid time sequence`);
      }
    }
    
    return anomalies;
  }
  
  private static logDelayError(delayId: string, error: Error): void {
    // 实现错误日志记录
  }

  private static notifyDelayFailure(delayId: string, error: Error): void {
    // 通知前端延时执行失败
  }
}
```

## 总结

延时容器管理模块的核心优势：

1. **灵活的容器设计** - 支持多层嵌套和并行执行
2. **精确的时间控制** - 基于绝对时间戳的精确触发
3. **高效的状态管理** - 优化的触发检测和状态更新
4. **完善的可视化支持** - 为前端提供丰富的预览数据
5. **强大的错误处理** - 异常检测和恢复机制
6. **性能优化** - 排序优化和预测性检查

这个模块为任务编排器提供了强大的延时控制能力，支持复杂的时间编排需求。
