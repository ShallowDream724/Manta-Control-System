# 任务编排器 - 实时预览模块

## 核心设计理念

实时预览模块为用户提供任务执行的可视化预览，核心特点：
1. **实时更新** - 编辑时立即更新预览
2. **可折叠显示** - 循环和延时支持折叠/展开
3. **时间线视图** - 清晰显示执行顺序和时间关系
4. **执行状态反馈** - 实时显示任务执行进度
5. **直观的视觉设计** - 用颜色和图标区分不同类型

## 预览组件架构

### 主预览组件
```typescript
// 任务预览主组件
interface TaskPreviewProps {
  task: Task;
  executionState?: TaskExecutionState;
  deviceConfigs: DeviceConfig[];
  isExecuting?: boolean;
}

const TaskPreview: React.FC<TaskPreviewProps> = ({ 
  task, executionState, deviceConfigs, isExecuting 
}) => {
  const [expandedItems, setExpandedItems] = useState<Set<string>>(new Set());
  
  const toggleExpanded = (itemId: string) => {
    const newExpanded = new Set(expandedItems);
    if (newExpanded.has(itemId)) {
      newExpanded.delete(itemId);
    } else {
      newExpanded.add(itemId);
    }
    setExpandedItems(newExpanded);
  };
  
  return (
    <div className="task-preview bg-white border rounded-lg p-4">
      <PreviewHeader 
        task={task}
        executionState={executionState}
        isExecuting={isExecuting}
      />
      
      <div className="preview-content mt-4">
        {task.steps.map((step, stepIndex) => (
          <StepPreview
            key={step.id}
            step={step}
            stepIndex={stepIndex}
            deviceConfigs={deviceConfigs}
            executionState={executionState}
            isExpanded={expandedItems.has(step.id)}
            onToggleExpand={() => toggleExpanded(step.id)}
            expandedItems={expandedItems}
            onToggleItem={toggleExpanded}
          />
        ))}
      </div>
    </div>
  );
};
```

### 步骤预览组件
```typescript
// 步骤预览组件
interface StepPreviewProps {
  step: Step;
  stepIndex: number;
  deviceConfigs: DeviceConfig[];
  executionState?: TaskExecutionState;
  isExpanded: boolean;
  onToggleExpand: () => void;
  expandedItems: Set<string>;
  onToggleItem: (itemId: string) => void;
}

const StepPreview: React.FC<StepPreviewProps> = ({ 
  step, stepIndex, deviceConfigs, executionState, 
  isExpanded, onToggleExpand, expandedItems, onToggleItem 
}) => {
  const isCurrentStep = executionState?.currentStepIndex === stepIndex;
  const isCompleted = executionState && executionState.currentStepIndex > stepIndex;
  
  const stepStatus = isCompleted ? 'completed' : isCurrentStep ? 'current' : 'pending';
  
  return (
    <div className={`step-preview mb-4 border rounded-lg ${getStepStatusClass(stepStatus)}`}>
      <div 
        className="step-header p-3 cursor-pointer flex items-center justify-between"
        onClick={onToggleExpand}
      >
        <div className="flex items-center space-x-3">
          <StepStatusIcon status={stepStatus} />
          <span className="font-medium">步骤 {stepIndex + 1}: {step.name}</span>
          <ParallelIndicator />
        </div>
        <ExpandIcon isExpanded={isExpanded} />
      </div>
      
      {isExpanded && (
        <div className="step-content p-3 pt-0">
          {/* 并行执行提示 */}
          <div className="parallel-notice mb-3 p-2 bg-blue-50 rounded text-sm">
            <span className="text-blue-700">
              📋 以下内容并行执行（同时开始）
            </span>
          </div>
          
          {/* 普通动作预览 */}
          {step.actions.length > 0 && (
            <ActionListPreview
              title="普通动作"
              actions={step.actions}
              deviceConfigs={deviceConfigs}
              executionState={executionState}
              expandedItems={expandedItems}
              onToggleItem={onToggleItem}
            />
          )}
          
          {/* 循环预览 */}
          {step.parallelLoops.length > 0 && (
            <div className="loops-preview mt-3">
              <h4 className="text-sm font-medium text-gray-700 mb-2">并行循环</h4>
              {step.parallelLoops.map(loop => (
                <LoopPreview
                  key={loop.id}
                  loop={loop}
                  deviceConfigs={deviceConfigs}
                  executionState={executionState}
                  isExpanded={expandedItems.has(loop.id)}
                  onToggleExpand={() => onToggleItem(loop.id)}
                  expandedItems={expandedItems}
                  onToggleItem={onToggleItem}
                />
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};
```

## 循环预览设计

### 可折叠循环预览
```typescript
// 循环预览组件
interface LoopPreviewProps {
  loop: ParallelLoop;
  deviceConfigs: DeviceConfig[];
  executionState?: TaskExecutionState;
  isExpanded: boolean;
  onToggleExpand: () => void;
  expandedItems: Set<string>;
  onToggleItem: (itemId: string) => void;
}

const LoopPreview: React.FC<LoopPreviewProps> = ({ 
  loop, deviceConfigs, executionState, 
  isExpanded, onToggleExpand, expandedItems, onToggleItem 
}) => {
  const loopState = executionState?.loopStates.get(loop.id);
  const progress = loopState ? (loopState.currentIteration / loop.iterations) * 100 : 0;
  
  return (
    <div className="loop-preview border-l-4 border-green-500 pl-4 mb-3 bg-green-50 rounded">
      <div 
        className="loop-header p-2 cursor-pointer flex items-center justify-between"
        onClick={onToggleExpand}
      >
        <div className="flex items-center space-x-2">
          <span className="text-green-600">🔄</span>
          <span className="font-medium text-sm">{loop.name}</span>
          <LoopSummary 
            iterations={loop.iterations}
            intervalMs={loop.intervalMs}
            currentIteration={loopState?.currentIteration}
          />
        </div>
        <ExpandIcon isExpanded={isExpanded} />
      </div>
      
      {/* 循环进度条 */}
      {loopState && (
        <div className="progress-bar mx-2 mb-2">
          <div className="bg-gray-200 rounded-full h-2">
            <div 
              className="bg-green-500 h-2 rounded-full transition-all duration-300"
              style={{ width: `${progress}%` }}
            />
          </div>
          <div className="text-xs text-gray-600 mt-1">
            进度: {loopState.currentIteration}/{loop.iterations} 
            ({Math.round(progress)}%)
          </div>
        </div>
      )}
      
      {isExpanded && (
        <div className="loop-content p-2 pt-0">
          {/* 串行执行提示 */}
          <div className="serial-notice mb-3 p-2 bg-yellow-50 rounded text-sm">
            <span className="text-yellow-700">
              🔄 子步骤串行执行（子步骤1完成后执行子步骤2）
            </span>
          </div>
          
          {/* 子步骤预览 */}
          <div className="substeps-preview">
            {loop.subSteps.map((subStep, subStepIndex) => (
              <SubStepPreview
                key={subStep.id}
                subStep={subStep}
                subStepIndex={subStepIndex}
                deviceConfigs={deviceConfigs}
                loopState={loopState}
                isExpanded={expandedItems.has(subStep.id)}
                onToggleExpand={() => onToggleItem(subStep.id)}
                expandedItems={expandedItems}
                onToggleItem={onToggleItem}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

### 子步骤预览
```typescript
// 子步骤预览组件
interface SubStepPreviewProps {
  subStep: SubStep;
  subStepIndex: number;
  deviceConfigs: DeviceConfig[];
  loopState?: LoopState;
  isExpanded: boolean;
  onToggleExpand: () => void;
  expandedItems: Set<string>;
  onToggleItem: (itemId: string) => void;
}

const SubStepPreview: React.FC<SubStepPreviewProps> = ({ 
  subStep, subStepIndex, deviceConfigs, loopState,
  isExpanded, onToggleExpand, expandedItems, onToggleItem 
}) => {
  const isCurrentSubStep = loopState?.currentSubStepIndex === subStepIndex;
  const isCompleted = loopState && loopState.currentSubStepIndex > subStepIndex;
  
  const subStepStatus = isCompleted ? 'completed' : isCurrentSubStep ? 'current' : 'pending';
  
  return (
    <div className={`substep-preview mb-2 border rounded ${getSubStepStatusClass(subStepStatus)}`}>
      <div 
        className="substep-header p-2 cursor-pointer flex items-center justify-between"
        onClick={onToggleExpand}
      >
        <div className="flex items-center space-x-2">
          <SubStepStatusIcon status={subStepStatus} />
          <span className="text-sm font-medium">子步骤 {subStepIndex + 1}: {subStep.name}</span>
          <ParallelIndicator size="small" />
        </div>
        <ExpandIcon isExpanded={isExpanded} size="small" />
      </div>
      
      {isExpanded && (
        <div className="substep-content p-2 pt-0">
          <ActionListPreview
            actions={subStep.actions}
            deviceConfigs={deviceConfigs}
            size="small"
            expandedItems={expandedItems}
            onToggleItem={onToggleItem}
          />
        </div>
      )}
    </div>
  );
};
```

## 延时预览设计

### 可折叠延时预览
```typescript
// 延时动作预览组件
interface DelayPreviewProps {
  delayAction: DelayAction;
  deviceConfigs: DeviceConfig[];
  nestingLevel: number;
  isExpanded: boolean;
  onToggleExpand: () => void;
  expandedItems: Set<string>;
  onToggleItem: (itemId: string) => void;
  delayState?: DelayState;
}

const DelayPreview: React.FC<DelayPreviewProps> = ({ 
  delayAction, deviceConfigs, nestingLevel,
  isExpanded, onToggleExpand, expandedItems, onToggleItem, delayState 
}) => {
  const borderColor = nestingLevel % 2 === 0 ? 'border-purple-500' : 'border-indigo-500';
  const bgColor = nestingLevel % 2 === 0 ? 'bg-purple-50' : 'bg-indigo-50';
  
  const isTriggered = delayState?.isTriggered || false;
  const remainingTime = delayState ? Math.max(0, delayState.triggerTime - Date.now()) : delayAction.delayMs;
  
  return (
    <div className={`delay-preview border-l-4 ${borderColor} pl-4 mb-3 ${bgColor} rounded`}>
      <div 
        className="delay-header p-2 cursor-pointer flex items-center justify-between"
        onClick={onToggleExpand}
      >
        <div className="flex items-center space-x-2">
          <DelayStatusIcon isTriggered={isTriggered} />
          <span className="text-sm font-medium">{delayAction.name}</span>
          <DelayTimeInfo 
            delayMs={delayAction.delayMs}
            remainingTime={remainingTime}
            isTriggered={isTriggered}
          />
        </div>
        <ExpandIcon isExpanded={isExpanded} />
      </div>
      
      {isExpanded && (
        <div className="delay-content p-2 pt-0">
          {/* 延时说明 */}
          <div className="delay-notice mb-3 p-2 bg-purple-100 rounded text-sm">
            <span className="text-purple-700">
              ⏰ 延时 {formatTime(delayAction.delayMs)} 后并行执行以下内容
            </span>
          </div>
          
          {/* 嵌套内容预览 */}
          <NestedActionPreview
            actions={delayAction.actions}
            deviceConfigs={deviceConfigs}
            nestingLevel={nestingLevel + 1}
            expandedItems={expandedItems}
            onToggleItem={onToggleItem}
          />
        </div>
      )}
    </div>
  );
};
```

## 时间线视图

### 执行时间线
```typescript
// 时间线预览组件
interface TimelinePreviewProps {
  task: Task;
  deviceConfigs: DeviceConfig[];
  executionState?: TaskExecutionState;
}

const TimelinePreview: React.FC<TimelinePreviewProps> = ({ 
  task, deviceConfigs, executionState 
}) => {
  const timelineEvents = useMemo(() => 
    generateTimelineEvents(task), [task]
  );
  
  const currentTime = executionState ? Date.now() - executionState.startTime : 0;
  
  return (
    <div className="timeline-preview bg-white border rounded-lg p-4">
      <h3 className="text-lg font-medium mb-4">执行时间线</h3>
      
      <div className="timeline-container relative">
        {/* 时间轴 */}
        <div className="timeline-axis absolute left-0 top-0 bottom-0 w-1 bg-gray-300" />
        
        {/* 当前时间指示器 */}
        {executionState && (
          <CurrentTimeIndicator currentTime={currentTime} />
        )}
        
        {/* 时间线事件 */}
        <div className="timeline-events ml-8">
          {timelineEvents.map((event, index) => (
            <TimelineEvent
              key={index}
              event={event}
              deviceConfigs={deviceConfigs}
              isActive={currentTime >= event.time}
              isPast={currentTime > event.time + event.duration}
            />
          ))}
        </div>
      </div>
    </div>
  );
};

// 时间线事件组件
interface TimelineEventProps {
  event: TimelineEventData;
  deviceConfigs: DeviceConfig[];
  isActive: boolean;
  isPast: boolean;
}

const TimelineEvent: React.FC<TimelineEventProps> = ({ 
  event, deviceConfigs, isActive, isPast 
}) => {
  const statusClass = isPast ? 'opacity-50' : isActive ? 'ring-2 ring-blue-500' : '';
  
  return (
    <div className={`timeline-event mb-4 p-3 border rounded-lg ${statusClass}`}>
      <div className="event-header flex items-center justify-between mb-2">
        <span className="text-sm font-medium">{event.title}</span>
        <span className="text-xs text-gray-500">{formatTime(event.time)}</span>
      </div>
      
      <div className="event-actions">
        {event.actions.map((action, index) => (
          <ActionPreviewItem
            key={index}
            action={action}
            deviceConfigs={deviceConfigs}
            size="small"
          />
        ))}
      </div>
    </div>
  );
};
```

## 实时状态更新

### WebSocket状态同步
```typescript
// 实时状态更新hook
function useTaskExecutionState(taskId: string) {
  const [executionState, setExecutionState] = useState<TaskExecutionState | null>(null);
  
  useEffect(() => {
    const ws = new WebSocket(`ws://localhost:3001/task-execution/${taskId}`);
    
    ws.onmessage = (event) => {
      const update = JSON.parse(event.data);
      if (update.type === 'task_execution_update') {
        setExecutionState(update.data);
      }
    };
    
    return () => ws.close();
  }, [taskId]);
  
  return executionState;
}

// 实时预览容器
const RealTimeTaskPreview: React.FC<{ task: Task; deviceConfigs: DeviceConfig[] }> = ({ 
  task, deviceConfigs 
}) => {
  const executionState = useTaskExecutionState(task.id);
  const [viewMode, setViewMode] = useState<'structure' | 'timeline'>('structure');
  
  return (
    <div className="realtime-preview">
      <div className="preview-controls mb-4 flex items-center justify-between">
        <div className="view-mode-toggle">
          <button
            onClick={() => setViewMode('structure')}
            className={`px-3 py-1 rounded-l ${viewMode === 'structure' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
          >
            结构视图
          </button>
          <button
            onClick={() => setViewMode('timeline')}
            className={`px-3 py-1 rounded-r ${viewMode === 'timeline' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
          >
            时间线视图
          </button>
        </div>
        
        {executionState && (
          <ExecutionStatus executionState={executionState} />
        )}
      </div>
      
      {viewMode === 'structure' ? (
        <TaskPreview 
          task={task}
          executionState={executionState}
          deviceConfigs={deviceConfigs}
          isExecuting={!!executionState}
        />
      ) : (
        <TimelinePreview
          task={task}
          deviceConfigs={deviceConfigs}
          executionState={executionState}
        />
      )}
    </div>
  );
};
```

## 工具函数

### 预览数据生成
```typescript
// 生成时间线事件
function generateTimelineEvents(task: Task): TimelineEventData[] {
  const events: TimelineEventData[] = [];
  let currentTime = 0;
  
  task.steps.forEach((step, stepIndex) => {
    // 步骤开始事件
    events.push({
      time: currentTime,
      title: `步骤 ${stepIndex + 1}: ${step.name}`,
      type: 'step_start',
      actions: step.actions.filter(a => a.type !== 'delay'),
      duration: calculateStepDuration(step)
    });
    
    // 循环事件
    step.parallelLoops.forEach(loop => {
      for (let i = 0; i < loop.iterations; i++) {
        const loopTime = currentTime + (i * loop.intervalMs);
        events.push({
          time: loopTime,
          title: `${loop.name} (第${i+1}次)`,
          type: 'loop_iteration',
          actions: extractLoopActions(loop),
          duration: calculateLoopIterationDuration(loop)
        });
      }
    });
    
    // 延时事件
    addDelayEvents(events, step.actions, currentTime);
    
    currentTime += calculateStepDuration(step);
  });
  
  return events.sort((a, b) => a.time - b.time);
}

// 格式化时间显示
function formatTime(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
  return `${Math.floor(ms / 60000)}m ${Math.floor((ms % 60000) / 1000)}s`;
}
```

## 总结

实时预览模块的核心优势：

1. **直观的可视化** - 清晰展示任务结构和执行状态
2. **灵活的折叠控制** - 用户可自由控制显示详细程度
3. **实时状态反馈** - WebSocket同步执行状态
4. **多视图支持** - 结构视图和时间线视图
5. **丰富的状态指示** - 颜色和图标清晰表示状态
6. **嵌套内容支持** - 完美处理复杂的嵌套结构

这个预览模块为用户提供了完整的任务执行可视化体验。
