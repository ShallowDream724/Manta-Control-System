# ä»»åŠ¡ç¼–æ’å™¨ - å®æ—¶é¢„è§ˆæ¨¡å—

## æ ¸å¿ƒè®¾è®¡ç†å¿µ

å®æ—¶é¢„è§ˆæ¨¡å—ä¸ºç”¨æˆ·æä¾›ä»»åŠ¡æ‰§è¡Œçš„å¯è§†åŒ–é¢„è§ˆï¼Œæ ¸å¿ƒç‰¹ç‚¹ï¼š
1. **å®æ—¶æ›´æ–°** - ç¼–è¾‘æ—¶ç«‹å³æ›´æ–°é¢„è§ˆ
2. **å¯æŠ˜å æ˜¾ç¤º** - å¾ªç¯å’Œå»¶æ—¶æ”¯æŒæŠ˜å /å±•å¼€
3. **æ—¶é—´çº¿è§†å›¾** - æ¸…æ™°æ˜¾ç¤ºæ‰§è¡Œé¡ºåºå’Œæ—¶é—´å…³ç³»
4. **æ‰§è¡ŒçŠ¶æ€åé¦ˆ** - å®æ—¶æ˜¾ç¤ºä»»åŠ¡æ‰§è¡Œè¿›åº¦
5. **ç›´è§‚çš„è§†è§‰è®¾è®¡** - ç”¨é¢œè‰²å’Œå›¾æ ‡åŒºåˆ†ä¸åŒç±»å‹

## é¢„è§ˆç»„ä»¶æ¶æ„

### ä¸»é¢„è§ˆç»„ä»¶
```typescript
// ä»»åŠ¡é¢„è§ˆä¸»ç»„ä»¶
interface TaskPreviewProps {
  task: Task;
  executionState?: TaskExecutionState;
  deviceConfigs: DeviceConfig[];
  isExecuting?: boolean;
}

const TaskPreview: React.FC<TaskPreviewProps> = ({ 
  task, executionState, deviceConfigs, isExecuting 
}) => {
  const [expandedItems, setExpandedItems] = useState<Set<string>>(new Set());
  
  const toggleExpanded = (itemId: string) => {
    const newExpanded = new Set(expandedItems);
    if (newExpanded.has(itemId)) {
      newExpanded.delete(itemId);
    } else {
      newExpanded.add(itemId);
    }
    setExpandedItems(newExpanded);
  };
  
  return (
    <div className="task-preview bg-white border rounded-lg p-4">
      <PreviewHeader 
        task={task}
        executionState={executionState}
        isExecuting={isExecuting}
      />
      
      <div className="preview-content mt-4">
        {task.steps.map((step, stepIndex) => (
          <StepPreview
            key={step.id}
            step={step}
            stepIndex={stepIndex}
            deviceConfigs={deviceConfigs}
            executionState={executionState}
            isExpanded={expandedItems.has(step.id)}
            onToggleExpand={() => toggleExpanded(step.id)}
            expandedItems={expandedItems}
            onToggleItem={toggleExpanded}
          />
        ))}
      </div>
    </div>
  );
};
```

### æ­¥éª¤é¢„è§ˆç»„ä»¶
```typescript
// æ­¥éª¤é¢„è§ˆç»„ä»¶
interface StepPreviewProps {
  step: Step;
  stepIndex: number;
  deviceConfigs: DeviceConfig[];
  executionState?: TaskExecutionState;
  isExpanded: boolean;
  onToggleExpand: () => void;
  expandedItems: Set<string>;
  onToggleItem: (itemId: string) => void;
}

const StepPreview: React.FC<StepPreviewProps> = ({ 
  step, stepIndex, deviceConfigs, executionState, 
  isExpanded, onToggleExpand, expandedItems, onToggleItem 
}) => {
  const isCurrentStep = executionState?.currentStepIndex === stepIndex;
  const isCompleted = executionState && executionState.currentStepIndex > stepIndex;
  
  const stepStatus = isCompleted ? 'completed' : isCurrentStep ? 'current' : 'pending';
  
  return (
    <div className={`step-preview mb-4 border rounded-lg ${getStepStatusClass(stepStatus)}`}>
      <div 
        className="step-header p-3 cursor-pointer flex items-center justify-between"
        onClick={onToggleExpand}
      >
        <div className="flex items-center space-x-3">
          <StepStatusIcon status={stepStatus} />
          <span className="font-medium">æ­¥éª¤ {stepIndex + 1}: {step.name}</span>
          <ParallelIndicator />
        </div>
        <ExpandIcon isExpanded={isExpanded} />
      </div>
      
      {isExpanded && (
        <div className="step-content p-3 pt-0">
          {/* å¹¶è¡Œæ‰§è¡Œæç¤º */}
          <div className="parallel-notice mb-3 p-2 bg-blue-50 rounded text-sm">
            <span className="text-blue-700">
              ğŸ“‹ ä»¥ä¸‹å†…å®¹å¹¶è¡Œæ‰§è¡Œï¼ˆåŒæ—¶å¼€å§‹ï¼‰
            </span>
          </div>
          
          {/* æ™®é€šåŠ¨ä½œé¢„è§ˆ */}
          {step.actions.length > 0 && (
            <ActionListPreview
              title="æ™®é€šåŠ¨ä½œ"
              actions={step.actions}
              deviceConfigs={deviceConfigs}
              executionState={executionState}
              expandedItems={expandedItems}
              onToggleItem={onToggleItem}
            />
          )}
          
          {/* å¾ªç¯é¢„è§ˆ */}
          {step.parallelLoops.length > 0 && (
            <div className="loops-preview mt-3">
              <h4 className="text-sm font-medium text-gray-700 mb-2">å¹¶è¡Œå¾ªç¯</h4>
              {step.parallelLoops.map(loop => (
                <LoopPreview
                  key={loop.id}
                  loop={loop}
                  deviceConfigs={deviceConfigs}
                  executionState={executionState}
                  isExpanded={expandedItems.has(loop.id)}
                  onToggleExpand={() => onToggleItem(loop.id)}
                  expandedItems={expandedItems}
                  onToggleItem={onToggleItem}
                />
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};
```

## å¾ªç¯é¢„è§ˆè®¾è®¡

### å¯æŠ˜å å¾ªç¯é¢„è§ˆ
```typescript
// å¾ªç¯é¢„è§ˆç»„ä»¶
interface LoopPreviewProps {
  loop: ParallelLoop;
  deviceConfigs: DeviceConfig[];
  executionState?: TaskExecutionState;
  isExpanded: boolean;
  onToggleExpand: () => void;
  expandedItems: Set<string>;
  onToggleItem: (itemId: string) => void;
}

const LoopPreview: React.FC<LoopPreviewProps> = ({ 
  loop, deviceConfigs, executionState, 
  isExpanded, onToggleExpand, expandedItems, onToggleItem 
}) => {
  const loopState = executionState?.loopStates.get(loop.id);
  const progress = loopState ? (loopState.currentIteration / loop.iterations) * 100 : 0;
  
  return (
    <div className="loop-preview border-l-4 border-green-500 pl-4 mb-3 bg-green-50 rounded">
      <div 
        className="loop-header p-2 cursor-pointer flex items-center justify-between"
        onClick={onToggleExpand}
      >
        <div className="flex items-center space-x-2">
          <span className="text-green-600">ğŸ”„</span>
          <span className="font-medium text-sm">{loop.name}</span>
          <LoopSummary 
            iterations={loop.iterations}
            intervalMs={loop.intervalMs}
            currentIteration={loopState?.currentIteration}
          />
        </div>
        <ExpandIcon isExpanded={isExpanded} />
      </div>
      
      {/* å¾ªç¯è¿›åº¦æ¡ */}
      {loopState && (
        <div className="progress-bar mx-2 mb-2">
          <div className="bg-gray-200 rounded-full h-2">
            <div 
              className="bg-green-500 h-2 rounded-full transition-all duration-300"
              style={{ width: `${progress}%` }}
            />
          </div>
          <div className="text-xs text-gray-600 mt-1">
            è¿›åº¦: {loopState.currentIteration}/{loop.iterations} 
            ({Math.round(progress)}%)
          </div>
        </div>
      )}
      
      {isExpanded && (
        <div className="loop-content p-2 pt-0">
          {/* ä¸²è¡Œæ‰§è¡Œæç¤º */}
          <div className="serial-notice mb-3 p-2 bg-yellow-50 rounded text-sm">
            <span className="text-yellow-700">
              ğŸ”„ å­æ­¥éª¤ä¸²è¡Œæ‰§è¡Œï¼ˆå­æ­¥éª¤1å®Œæˆåæ‰§è¡Œå­æ­¥éª¤2ï¼‰
            </span>
          </div>
          
          {/* å­æ­¥éª¤é¢„è§ˆ */}
          <div className="substeps-preview">
            {loop.subSteps.map((subStep, subStepIndex) => (
              <SubStepPreview
                key={subStep.id}
                subStep={subStep}
                subStepIndex={subStepIndex}
                deviceConfigs={deviceConfigs}
                loopState={loopState}
                isExpanded={expandedItems.has(subStep.id)}
                onToggleExpand={() => onToggleItem(subStep.id)}
                expandedItems={expandedItems}
                onToggleItem={onToggleItem}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

### å­æ­¥éª¤é¢„è§ˆ
```typescript
// å­æ­¥éª¤é¢„è§ˆç»„ä»¶
interface SubStepPreviewProps {
  subStep: SubStep;
  subStepIndex: number;
  deviceConfigs: DeviceConfig[];
  loopState?: LoopState;
  isExpanded: boolean;
  onToggleExpand: () => void;
  expandedItems: Set<string>;
  onToggleItem: (itemId: string) => void;
}

const SubStepPreview: React.FC<SubStepPreviewProps> = ({ 
  subStep, subStepIndex, deviceConfigs, loopState,
  isExpanded, onToggleExpand, expandedItems, onToggleItem 
}) => {
  const isCurrentSubStep = loopState?.currentSubStepIndex === subStepIndex;
  const isCompleted = loopState && loopState.currentSubStepIndex > subStepIndex;
  
  const subStepStatus = isCompleted ? 'completed' : isCurrentSubStep ? 'current' : 'pending';
  
  return (
    <div className={`substep-preview mb-2 border rounded ${getSubStepStatusClass(subStepStatus)}`}>
      <div 
        className="substep-header p-2 cursor-pointer flex items-center justify-between"
        onClick={onToggleExpand}
      >
        <div className="flex items-center space-x-2">
          <SubStepStatusIcon status={subStepStatus} />
          <span className="text-sm font-medium">å­æ­¥éª¤ {subStepIndex + 1}: {subStep.name}</span>
          <ParallelIndicator size="small" />
        </div>
        <ExpandIcon isExpanded={isExpanded} size="small" />
      </div>
      
      {isExpanded && (
        <div className="substep-content p-2 pt-0">
          <ActionListPreview
            actions={subStep.actions}
            deviceConfigs={deviceConfigs}
            size="small"
            expandedItems={expandedItems}
            onToggleItem={onToggleItem}
          />
        </div>
      )}
    </div>
  );
};
```

## å»¶æ—¶é¢„è§ˆè®¾è®¡

### å¯æŠ˜å å»¶æ—¶é¢„è§ˆ
```typescript
// å»¶æ—¶åŠ¨ä½œé¢„è§ˆç»„ä»¶
interface DelayPreviewProps {
  delayAction: DelayAction;
  deviceConfigs: DeviceConfig[];
  nestingLevel: number;
  isExpanded: boolean;
  onToggleExpand: () => void;
  expandedItems: Set<string>;
  onToggleItem: (itemId: string) => void;
  delayState?: DelayState;
}

const DelayPreview: React.FC<DelayPreviewProps> = ({ 
  delayAction, deviceConfigs, nestingLevel,
  isExpanded, onToggleExpand, expandedItems, onToggleItem, delayState 
}) => {
  const borderColor = nestingLevel % 2 === 0 ? 'border-purple-500' : 'border-indigo-500';
  const bgColor = nestingLevel % 2 === 0 ? 'bg-purple-50' : 'bg-indigo-50';
  
  const isTriggered = delayState?.isTriggered || false;
  const remainingTime = delayState ? Math.max(0, delayState.triggerTime - Date.now()) : delayAction.delayMs;
  
  return (
    <div className={`delay-preview border-l-4 ${borderColor} pl-4 mb-3 ${bgColor} rounded`}>
      <div 
        className="delay-header p-2 cursor-pointer flex items-center justify-between"
        onClick={onToggleExpand}
      >
        <div className="flex items-center space-x-2">
          <DelayStatusIcon isTriggered={isTriggered} />
          <span className="text-sm font-medium">{delayAction.name}</span>
          <DelayTimeInfo 
            delayMs={delayAction.delayMs}
            remainingTime={remainingTime}
            isTriggered={isTriggered}
          />
        </div>
        <ExpandIcon isExpanded={isExpanded} />
      </div>
      
      {isExpanded && (
        <div className="delay-content p-2 pt-0">
          {/* å»¶æ—¶è¯´æ˜ */}
          <div className="delay-notice mb-3 p-2 bg-purple-100 rounded text-sm">
            <span className="text-purple-700">
              â° å»¶æ—¶ {formatTime(delayAction.delayMs)} åå¹¶è¡Œæ‰§è¡Œä»¥ä¸‹å†…å®¹
            </span>
          </div>
          
          {/* åµŒå¥—å†…å®¹é¢„è§ˆ */}
          <NestedActionPreview
            actions={delayAction.actions}
            deviceConfigs={deviceConfigs}
            nestingLevel={nestingLevel + 1}
            expandedItems={expandedItems}
            onToggleItem={onToggleItem}
          />
        </div>
      )}
    </div>
  );
};
```

## æ—¶é—´çº¿è§†å›¾

### æ‰§è¡Œæ—¶é—´çº¿
```typescript
// æ—¶é—´çº¿é¢„è§ˆç»„ä»¶
interface TimelinePreviewProps {
  task: Task;
  deviceConfigs: DeviceConfig[];
  executionState?: TaskExecutionState;
}

const TimelinePreview: React.FC<TimelinePreviewProps> = ({ 
  task, deviceConfigs, executionState 
}) => {
  const timelineEvents = useMemo(() => 
    generateTimelineEvents(task), [task]
  );
  
  const currentTime = executionState ? Date.now() - executionState.startTime : 0;
  
  return (
    <div className="timeline-preview bg-white border rounded-lg p-4">
      <h3 className="text-lg font-medium mb-4">æ‰§è¡Œæ—¶é—´çº¿</h3>
      
      <div className="timeline-container relative">
        {/* æ—¶é—´è½´ */}
        <div className="timeline-axis absolute left-0 top-0 bottom-0 w-1 bg-gray-300" />
        
        {/* å½“å‰æ—¶é—´æŒ‡ç¤ºå™¨ */}
        {executionState && (
          <CurrentTimeIndicator currentTime={currentTime} />
        )}
        
        {/* æ—¶é—´çº¿äº‹ä»¶ */}
        <div className="timeline-events ml-8">
          {timelineEvents.map((event, index) => (
            <TimelineEvent
              key={index}
              event={event}
              deviceConfigs={deviceConfigs}
              isActive={currentTime >= event.time}
              isPast={currentTime > event.time + event.duration}
            />
          ))}
        </div>
      </div>
    </div>
  );
};

// æ—¶é—´çº¿äº‹ä»¶ç»„ä»¶
interface TimelineEventProps {
  event: TimelineEventData;
  deviceConfigs: DeviceConfig[];
  isActive: boolean;
  isPast: boolean;
}

const TimelineEvent: React.FC<TimelineEventProps> = ({ 
  event, deviceConfigs, isActive, isPast 
}) => {
  const statusClass = isPast ? 'opacity-50' : isActive ? 'ring-2 ring-blue-500' : '';
  
  return (
    <div className={`timeline-event mb-4 p-3 border rounded-lg ${statusClass}`}>
      <div className="event-header flex items-center justify-between mb-2">
        <span className="text-sm font-medium">{event.title}</span>
        <span className="text-xs text-gray-500">{formatTime(event.time)}</span>
      </div>
      
      <div className="event-actions">
        {event.actions.map((action, index) => (
          <ActionPreviewItem
            key={index}
            action={action}
            deviceConfigs={deviceConfigs}
            size="small"
          />
        ))}
      </div>
    </div>
  );
};
```

## å®æ—¶çŠ¶æ€æ›´æ–°

### WebSocketçŠ¶æ€åŒæ­¥
```typescript
// å®æ—¶çŠ¶æ€æ›´æ–°hook
function useTaskExecutionState(taskId: string) {
  const [executionState, setExecutionState] = useState<TaskExecutionState | null>(null);
  
  useEffect(() => {
    const ws = new WebSocket(`ws://localhost:3001/task-execution/${taskId}`);
    
    ws.onmessage = (event) => {
      const update = JSON.parse(event.data);
      if (update.type === 'task_execution_update') {
        setExecutionState(update.data);
      }
    };
    
    return () => ws.close();
  }, [taskId]);
  
  return executionState;
}

// å®æ—¶é¢„è§ˆå®¹å™¨
const RealTimeTaskPreview: React.FC<{ task: Task; deviceConfigs: DeviceConfig[] }> = ({ 
  task, deviceConfigs 
}) => {
  const executionState = useTaskExecutionState(task.id);
  const [viewMode, setViewMode] = useState<'structure' | 'timeline'>('structure');
  
  return (
    <div className="realtime-preview">
      <div className="preview-controls mb-4 flex items-center justify-between">
        <div className="view-mode-toggle">
          <button
            onClick={() => setViewMode('structure')}
            className={`px-3 py-1 rounded-l ${viewMode === 'structure' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
          >
            ç»“æ„è§†å›¾
          </button>
          <button
            onClick={() => setViewMode('timeline')}
            className={`px-3 py-1 rounded-r ${viewMode === 'timeline' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
          >
            æ—¶é—´çº¿è§†å›¾
          </button>
        </div>
        
        {executionState && (
          <ExecutionStatus executionState={executionState} />
        )}
      </div>
      
      {viewMode === 'structure' ? (
        <TaskPreview 
          task={task}
          executionState={executionState}
          deviceConfigs={deviceConfigs}
          isExecuting={!!executionState}
        />
      ) : (
        <TimelinePreview
          task={task}
          deviceConfigs={deviceConfigs}
          executionState={executionState}
        />
      )}
    </div>
  );
};
```

## å·¥å…·å‡½æ•°

### é¢„è§ˆæ•°æ®ç”Ÿæˆ
```typescript
// ç”Ÿæˆæ—¶é—´çº¿äº‹ä»¶
function generateTimelineEvents(task: Task): TimelineEventData[] {
  const events: TimelineEventData[] = [];
  let currentTime = 0;
  
  task.steps.forEach((step, stepIndex) => {
    // æ­¥éª¤å¼€å§‹äº‹ä»¶
    events.push({
      time: currentTime,
      title: `æ­¥éª¤ ${stepIndex + 1}: ${step.name}`,
      type: 'step_start',
      actions: step.actions.filter(a => a.type !== 'delay'),
      duration: calculateStepDuration(step)
    });
    
    // å¾ªç¯äº‹ä»¶
    step.parallelLoops.forEach(loop => {
      for (let i = 0; i < loop.iterations; i++) {
        const loopTime = currentTime + (i * loop.intervalMs);
        events.push({
          time: loopTime,
          title: `${loop.name} (ç¬¬${i+1}æ¬¡)`,
          type: 'loop_iteration',
          actions: extractLoopActions(loop),
          duration: calculateLoopIterationDuration(loop)
        });
      }
    });
    
    // å»¶æ—¶äº‹ä»¶
    addDelayEvents(events, step.actions, currentTime);
    
    currentTime += calculateStepDuration(step);
  });
  
  return events.sort((a, b) => a.time - b.time);
}

// æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
function formatTime(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
  return `${Math.floor(ms / 60000)}m ${Math.floor((ms % 60000) / 1000)}s`;
}
```

## æ€»ç»“

å®æ—¶é¢„è§ˆæ¨¡å—çš„æ ¸å¿ƒä¼˜åŠ¿ï¼š

1. **ç›´è§‚çš„å¯è§†åŒ–** - æ¸…æ™°å±•ç¤ºä»»åŠ¡ç»“æ„å’Œæ‰§è¡ŒçŠ¶æ€
2. **çµæ´»çš„æŠ˜å æ§åˆ¶** - ç”¨æˆ·å¯è‡ªç”±æ§åˆ¶æ˜¾ç¤ºè¯¦ç»†ç¨‹åº¦
3. **å®æ—¶çŠ¶æ€åé¦ˆ** - WebSocketåŒæ­¥æ‰§è¡ŒçŠ¶æ€
4. **å¤šè§†å›¾æ”¯æŒ** - ç»“æ„è§†å›¾å’Œæ—¶é—´çº¿è§†å›¾
5. **ä¸°å¯Œçš„çŠ¶æ€æŒ‡ç¤º** - é¢œè‰²å’Œå›¾æ ‡æ¸…æ™°è¡¨ç¤ºçŠ¶æ€
6. **åµŒå¥—å†…å®¹æ”¯æŒ** - å®Œç¾å¤„ç†å¤æ‚çš„åµŒå¥—ç»“æ„

è¿™ä¸ªé¢„è§ˆæ¨¡å—ä¸ºç”¨æˆ·æä¾›äº†å®Œæ•´çš„ä»»åŠ¡æ‰§è¡Œå¯è§†åŒ–ä½“éªŒã€‚
