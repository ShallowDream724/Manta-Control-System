# 任务编排器 - 数据结构设计

## 核心设计理念

基于用户需求，任务编排器的数据结构必须支持：
1. **真并行执行** - 同一时刻的多个动作批量发送Arduino
2. **嵌套结构** - 步骤→循环→子步骤→动作的层次关系
3. **延时容器** - 延时后并行执行多个动作
4. **严格限制** - 循环内不能嵌套循环

## 数据结构定义

### 1. 基础动作类型
```typescript
// 基础动作 - 对应设备配置的具体操作
interface Action {
  id: string;
  type: 'device_control';  // 设备控制动作
  deviceId: string;        // 对应设备配置的ID
  actionType: 'power' | 'state';  // 功率控制或开关控制
  value: number | boolean; // 功率值(0-100)或开关状态(true/false)
}

// 延时动作 - 特殊的容器动作
interface DelayAction {
  id: string;
  type: 'delay';
  delayMs: number;         // 延时毫秒数
  actions: Action[];       // 延时后并行执行的动作列表
}
```

### 2. 子步骤结构
```typescript
// 子步骤 - 循环内的最小执行单元
interface SubStep {
  id: string;
  name: string;
  actions: (Action | DelayAction)[];  // 支持普通动作和延时动作
  // 注意：子步骤内不能包含循环
}
```

### 3. 并行循环结构
```typescript
// 并行循环 - 可独立执行的循环单元
interface ParallelLoop {
  id: string;
  name: string;
  iterations: number;      // 循环次数
  intervalMs: number;      // 循环间隔（毫秒）
  subSteps: SubStep[];     // 子步骤列表
  // 重要：循环内不能嵌套循环
}
```

### 4. 步骤结构
```typescript
// 步骤 - 任务的主要组成单元
interface Step {
  id: string;
  name: string;
  // 步骤内的内容并行执行
  actions: (Action | DelayAction)[];  // 普通动作（单次执行）
  parallelLoops: ParallelLoop[];      // 并行循环列表
}
```

### 5. 任务结构
```typescript
// 任务 - 完整的执行序列
interface Task {
  id: string;
  name: string;
  description?: string;
  steps: Step[];           // 步骤按顺序执行
  createdAt: number;
  updatedAt: number;
}
```

## 执行逻辑说明

### 正确的串行/并行规则
```typescript
// 步骤间串行执行
Task {
  steps: [step1, step2, step3]             // step1完成后执行step2，step2完成后执行step3
}

// 步骤内并行执行
Step {
  actions: [action1, action2, action3],     // 同时开始执行
  parallelLoops: [loop1, loop2, loop3],    // 同时开始执行
  delayActions: [delay1, delay2]           // 同时开始计时
}

// 循环内子步骤串行执行
ParallelLoop {
  subSteps: [subStep1, subStep2, subStep3] // subStep1完成后执行subStep2，依次串行
}

// 子步骤内并行执行（与步骤内逻辑相同）
SubStep {
  actions: [action1, action2, delayAction] // 同时执行
}

// 延时动作：延时后并行执行内容
DelayAction {
  delayMs: 1000,
  actions: [action1, action2, loop1]       // 延时1秒后，同时开始执行
}
```

### 嵌套限制
```typescript
// ✅ 允许的嵌套
Task → Step → Action
Task → Step → ParallelLoop → SubStep → Action
Task → Step → ParallelLoop → SubStep → DelayAction → Action
Task → Step → DelayAction → Action

// ❌ 禁止的嵌套
ParallelLoop → ParallelLoop  // 循环内不能嵌套循环
```

## 实时调度的数据结构

### 循环状态跟踪
```typescript
// 循环运行时状态
interface LoopState {
  loopId: string;
  currentIteration: number;    // 当前循环次数 (0-based)
  nextExecutionTime: number;   // 下次执行时间戳
  isActive: boolean;           // 是否活跃
  isPaused: boolean;           // 是否暂停
  subStepIndex: number;        // 当前子步骤索引
}

// 延时状态跟踪
interface DelayState {
  delayId: string;
  triggerTime: number;         // 触发时间戳
  isTriggered: boolean;        // 是否已触发
}

// 任务执行状态
interface TaskExecutionState {
  taskId: string;
  currentStepIndex: number;    // 当前步骤索引
  stepStartTime: number;       // 步骤开始时间
  loopStates: Map<string, LoopState>;     // 循环状态映射
  delayStates: Map<string, DelayState>;   // 延时状态映射
  isRunning: boolean;
  isPaused: boolean;
}
```

## 动作生成规则

### 设备动作生成
```typescript
// 根据设备配置动态生成可用动作
function generateDeviceActions(deviceConfigs: DeviceConfig[]): ActionTemplate[] {
  return deviceConfigs.map(device => {
    if (device.mode === 'pwm') {
      return {
        id: `${device.id}_power`,
        label: `${device.name} - 功率控制`,
        deviceId: device.id,
        actionType: 'power',
        valueType: 'number',
        valueRange: [0, device.maxPower || 100]
      };
    } else {
      return {
        id: `${device.id}_state`,
        label: `${device.name} - 开关控制`,
        deviceId: device.id,
        actionType: 'state',
        valueType: 'boolean'
      };
    }
  });
}
```

### 默认动作类型
```typescript
// 默认提供的动作类型
const DEFAULT_ACTION_TYPES = {
  LOOP: 'loop',        // 循环容器
  DELAY: 'delay'       // 延时容器
} as const;
```

## 数据验证规则

### 结构验证（主要用于导入时验证）
```typescript
function validateTaskStructure(task: Task): ValidationResult {
  const errors: string[] = [];

  // 验证步骤
  task.steps.forEach((step, stepIndex) => {
    // 验证循环嵌套（防止用户导入错误的JSON）
    step.parallelLoops.forEach((loop, loopIndex) => {
      loop.subSteps.forEach((subStep, subStepIndex) => {
        // 检查子步骤中是否包含循环（严格禁止）
        if (hasNestedLoop(subStep)) {
          errors.push(`步骤${stepIndex+1}的循环${loopIndex+1}的子步骤${subStepIndex+1}包含嵌套循环（不允许）`);
        }
      });
    });
  });

  return { isValid: errors.length === 0, errors };
}

// 注意：前端编辑器不会提供在子步骤中添加循环的选项
// 此验证主要用于导入外部配置文件时的安全检查
```

### 设备引用验证
```typescript
function validateDeviceReferences(task: Task, deviceConfigs: DeviceConfig[]): ValidationResult {
  const deviceIds = new Set(deviceConfigs.map(d => d.id));
  const errors: string[] = [];
  
  // 递归检查所有动作的设备引用
  function checkActions(actions: (Action | DelayAction)[], path: string) {
    actions.forEach((action, index) => {
      if (action.type === 'device_control') {
        if (!deviceIds.has(action.deviceId)) {
          errors.push(`${path}的动作${index+1}引用了不存在的设备: ${action.deviceId}`);
        }
      } else if (action.type === 'delay') {
        checkActions(action.actions, `${path}的延时动作${index+1}`);
      }
    });
  }
  
  // 检查所有步骤
  task.steps.forEach((step, stepIndex) => {
    checkActions(step.actions, `步骤${stepIndex+1}`);
    step.parallelLoops.forEach((loop, loopIndex) => {
      loop.subSteps.forEach((subStep, subStepIndex) => {
        checkActions(subStep.actions, `步骤${stepIndex+1}的循环${loopIndex+1}的子步骤${subStepIndex+1}`);
      });
    });
  });
  
  return { isValid: errors.length === 0, errors };
}
```

## 内存优化考虑

### 避免预展开
```typescript
// ❌ 错误的预展开方式（内存爆炸）
function expandTaskToTimeline(task: Task): TimelineEvent[] {
  // 这种方式会生成数百万个事件对象
  // 50循环 × 100次 × 50子步骤 × 20动作 = 5,000,000个对象
}

// ✅ 正确的实时计算方式
function calculateCurrentActions(executionState: TaskExecutionState, currentTime: number): Action[] {
  // 只计算当前时刻需要执行的动作
  // 内存占用恒定，与循环次数无关
}
```

### 状态管理优化
```typescript
// 使用Map进行高效的状态查找
class TaskExecutionManager {
  private loopStates = new Map<string, LoopState>();
  private delayStates = new Map<string, DelayState>();
  
  // O(1)时间复杂度的状态更新
  updateLoopState(loopId: string, state: Partial<LoopState>) {
    const current = this.loopStates.get(loopId);
    if (current) {
      this.loopStates.set(loopId, { ...current, ...state });
    }
  }
}
```

## 总结

这个数据结构设计的核心优势：

1. **清晰的层次关系** - 任务→步骤→循环→子步骤→动作
2. **严格的嵌套限制** - 防止循环嵌套导致的复杂性
3. **真并行支持** - 同级元素真正并行执行
4. **内存高效** - 避免预展开，实时计算
5. **类型安全** - 完整的TypeScript类型定义
6. **易于验证** - 清晰的验证规则和错误提示

这个设计为后续的实时调度引擎、前端编辑器等模块提供了坚实的基础。
