# 任务编排器 - 数据结构设计

## 核心设计理念

任务编排器本质上是一个**时间调度器**，核心功能：
1. **在正确的时间点发送正确的命令给Arduino**
2. **支持设备持续时间控制** - 如"充气泵80%功率运行10秒"
3. **支持延时并行执行** - 延时N秒后同时执行多个动作
4. **支持循环间隔控制** - 循环结束后等待指定时间再开始下次循环
5. **严格的嵌套限制** - 循环内不能嵌套循环

## 数据结构定义

### 1. 基础动作类型
```typescript
// 基础动作 - 对应设备配置的具体操作
interface Action {
  id: string;
  type: 'device_control';
  deviceId: string;        // 对应设备配置的ID
  actionType: 'power' | 'state';  // 功率控制或开关控制
  value: number | boolean; // 功率值(0-100)或开关状态(true/false)
  duration: number;        // 【必须】持续时间（毫秒）
  name?: string;           // 动作名称
}

// 延时动作 - 时间偏移容器
interface DelayAction {
  id: string;
  type: 'delay';
  name: string;
  delayMs: number;         // 延时毫秒数
  actions: (Action | DelayAction)[]; // 延时后并行执行的动作列表（支持嵌套）
  description?: string;    // 延时描述
}
```

### 2. 子步骤结构
```typescript
// 子步骤 - 循环内的最小执行单元
interface SubStep {
  id: string;
  name: string;
  actions: (Action | DelayAction)[];  // 支持普通动作和延时动作
  // 注意：子步骤内不能包含循环
}
```

### 3. 并行循环结构
```typescript
// 并行循环 - 可独立执行的循环单元
interface ParallelLoop {
  id: string;
  name: string;
  iterations: number;      // 循环次数
  intervalMs: number;      // 循环间隔（毫秒）
  subSteps: SubStep[];     // 子步骤列表
  // 重要：循环内不能嵌套循环
}
```

### 4. 步骤结构
```typescript
// 步骤 - 任务的主要组成单元
interface Step {
  id: string;
  name: string;
  // 步骤内的内容并行执行
  actions: (Action | DelayAction)[];  // 普通动作（单次执行）
  parallelLoops: ParallelLoop[];      // 并行循环列表
}
```

### 5. 任务结构
```typescript
// 任务 - 完整的执行序列
interface Task {
  id: string;
  name: string;
  description?: string;
  steps: Step[];           // 步骤按顺序执行
  createdAt: number;
  updatedAt: number;
}
```

## 执行逻辑说明

### 时间调度的核心原理
```typescript
// 示例：完整的时间调度
步骤1（第0秒开始）{
  // 第0秒：立即发送命令
  充气泵1: 80%功率，10秒  → Arduino收到：pump1=80%, duration=10s
  充气泵2: 60%功率，8秒   → Arduino收到：pump2=60%, duration=8s

  // 第5秒：延时后发送命令
  延时5秒 {
    阀门1: 开启，持续2秒    → 第5秒发送：valve1=true, duration=2s
    阀门2: 开启，持续3秒    → 第5秒发送：valve2=true, duration=3s

    // 第7秒：嵌套延时（5+2=7秒后）
    延时2秒 {
      抽气泵1: 100%功率，5秒 → 第7秒发送：pump3=100%, duration=5s
    }
  }

  // 第0秒：循环立即开始
  循环5次，间隔10秒 {
    子步骤1 {
      充气泵1: 50%功率，3秒  // duration = 3秒
    }
    子步骤2 {
      抽气泵1: 80%功率，2秒  // 第0秒开始，第2秒结束
      延时1秒 {
        阀门1: 开启，0.5秒    // 第1秒开始，第1.5秒结束
      }
      // duration = Max(2, 1+0.5) = 2秒
    }
    // 每次循环总时长 = 3+2 = 5秒
    // 循环时序：0秒开始→5秒结束→等待10秒→15秒开始第2次
  }
}
```

### 子步骤duration计算规则
```typescript
// 子步骤duration = Max(所有并行内容的完成时间)
function calculateSubStepDuration(subStep: SubStep): number {
  return calculateActionsDuration(subStep.actions, 0);
}

function calculateActionsDuration(actions: (Action | DelayAction)[], baseDelay: number): number {
  let maxDuration = 0;

  for (const action of actions) {
    if (action.type === 'device_control') {
      // 普通动作：baseDelay + action.duration
      maxDuration = Math.max(maxDuration, baseDelay + action.duration);
    } else if (action.type === 'delay') {
      // 延时动作：递归计算嵌套内容
      const delayedDuration = calculateActionsDuration(
        action.actions,
        baseDelay + action.delayMs
      );
      maxDuration = Math.max(maxDuration, delayedDuration);
    }
  }

  return maxDuration;
}
```

### 嵌套限制
```typescript
// ✅ 允许的嵌套
Task → Step → Action
Task → Step → ParallelLoop → SubStep → Action
Task → Step → ParallelLoop → SubStep → DelayAction → Action
Task → Step → DelayAction → Action

// ❌ 禁止的嵌套
ParallelLoop → ParallelLoop  // 循环内不能嵌套循环
```

## 实时调度的数据结构

### 循环状态跟踪
```typescript
// 循环运行时状态
interface LoopState {
  loopId: string;
  currentIteration: number;    // 当前循环次数 (0-based)
  nextExecutionTime: number;   // 下次执行时间戳
  isActive: boolean;           // 是否活跃
  isPaused: boolean;           // 是否暂停
  subStepIndex: number;        // 当前子步骤索引
}

// 延时状态跟踪
interface DelayState {
  delayId: string;
  triggerTime: number;         // 触发时间戳
  isTriggered: boolean;        // 是否已触发
}

// 任务执行状态
interface TaskExecutionState {
  taskId: string;
  currentStepIndex: number;    // 当前步骤索引
  stepStartTime: number;       // 步骤开始时间
  loopStates: Map<string, LoopState>;     // 循环状态映射
  delayStates: Map<string, DelayState>;   // 延时状态映射
  isRunning: boolean;
  isPaused: boolean;
}
```

## 动作生成规则

### 设备动作生成
```typescript
// 根据设备配置动态生成可用动作
function generateDeviceActions(deviceConfigs: DeviceConfig[]): ActionTemplate[] {
  return deviceConfigs.map(device => {
    if (device.mode === 'pwm') {
      return {
        id: `${device.id}_power`,
        label: `${device.name} - 功率控制`,
        deviceId: device.id,
        actionType: 'power',
        valueType: 'number',
        valueRange: [0, device.maxPower || 100]
      };
    } else {
      return {
        id: `${device.id}_state`,
        label: `${device.name} - 开关控制`,
        deviceId: device.id,
        actionType: 'state',
        valueType: 'boolean'
      };
    }
  });
}
```

### 默认动作类型
```typescript
// 默认提供的动作类型
const DEFAULT_ACTION_TYPES = {
  LOOP: 'loop',        // 循环容器
  DELAY: 'delay'       // 延时容器
} as const;
```

## 数据验证规则

### 结构验证（主要用于导入时验证）
```typescript
function validateTaskStructure(task: Task): ValidationResult {
  const errors: string[] = [];

  // 验证步骤
  task.steps.forEach((step, stepIndex) => {
    // 验证循环嵌套（防止用户导入错误的JSON）
    step.parallelLoops.forEach((loop, loopIndex) => {
      loop.subSteps.forEach((subStep, subStepIndex) => {
        // 检查子步骤中是否包含循环（严格禁止）
        if (hasNestedLoop(subStep)) {
          errors.push(`步骤${stepIndex+1}的循环${loopIndex+1}的子步骤${subStepIndex+1}包含嵌套循环（不允许）`);
        }
      });
    });
  });

  return { isValid: errors.length === 0, errors };
}

// 注意：前端编辑器不会提供在子步骤中添加循环的选项
// 此验证主要用于导入外部配置文件时的安全检查
```

### 设备引用验证
```typescript
function validateDeviceReferences(task: Task, deviceConfigs: DeviceConfig[]): ValidationResult {
  const deviceIds = new Set(deviceConfigs.map(d => d.id));
  const errors: string[] = [];
  
  // 递归检查所有动作的设备引用
  function checkActions(actions: (Action | DelayAction)[], path: string) {
    actions.forEach((action, index) => {
      if (action.type === 'device_control') {
        if (!deviceIds.has(action.deviceId)) {
          errors.push(`${path}的动作${index+1}引用了不存在的设备: ${action.deviceId}`);
        }
      } else if (action.type === 'delay') {
        checkActions(action.actions, `${path}的延时动作${index+1}`);
      }
    });
  }
  
  // 检查所有步骤
  task.steps.forEach((step, stepIndex) => {
    checkActions(step.actions, `步骤${stepIndex+1}`);
    step.parallelLoops.forEach((loop, loopIndex) => {
      loop.subSteps.forEach((subStep, subStepIndex) => {
        checkActions(subStep.actions, `步骤${stepIndex+1}的循环${loopIndex+1}的子步骤${subStepIndex+1}`);
      });
    });
  });
  
  return { isValid: errors.length === 0, errors };
}
```

## 内存优化考虑

### 避免预展开
```typescript
// ❌ 错误的预展开方式（内存爆炸）
function expandTaskToTimeline(task: Task): TimelineEvent[] {
  // 这种方式会生成数百万个事件对象
  // 50循环 × 100次 × 50子步骤 × 20动作 = 5,000,000个对象
}

// ✅ 正确的实时计算方式
function calculateCurrentActions(executionState: TaskExecutionState, currentTime: number): Action[] {
  // 只计算当前时刻需要执行的动作
  // 内存占用恒定，与循环次数无关
}
```

### 状态管理优化
```typescript
// 使用Map进行高效的状态查找
class TaskExecutionManager {
  private loopStates = new Map<string, LoopState>();
  private delayStates = new Map<string, DelayState>();
  
  // O(1)时间复杂度的状态更新
  updateLoopState(loopId: string, state: Partial<LoopState>) {
    const current = this.loopStates.get(loopId);
    if (current) {
      this.loopStates.set(loopId, { ...current, ...state });
    }
  }
}
```

## 总结

这个数据结构设计的核心优势：

1. **清晰的层次关系** - 任务→步骤→循环→子步骤→动作
2. **严格的嵌套限制** - 防止循环嵌套导致的复杂性
3. **真并行支持** - 同级元素真正并行执行
4. **内存高效** - 避免预展开，实时计算
5. **类型安全** - 完整的TypeScript类型定义
6. **易于验证** - 清晰的验证规则和错误提示

这个设计为后续的实时调度引擎、前端编辑器等模块提供了坚实的基础。
